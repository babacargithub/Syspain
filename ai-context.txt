I have a Laravel app with version 11.14.0

Here are my Models:
Abonnement.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Abonnement extends Model
{
    use HasFactory;

    protected $fillable = [
        'date_debut',
        'date_fin',
        'type',
        'prix',
    ];
    public function client(): BelongsTo
    {
        return $this->belongsTo(Client::class);
    }

    public function identifier() :string
    {
        return 'Abonnement de '. $this->client->identifier();

    }
}


Article.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\SoftDeletes;

class Article extends Model
{
    use HasFactory, SoftDeletes;
    use BoulangerieScope;

    protected $fillable = [
        'nom',
        'prix',
        'boulangerie_id',
    ];

    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }
}


ArticleProdPatisserie.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class ArticleProdPatisserie extends Model
{
    use HasFactory;

    protected $fillable = [
        'article_id',
        'prod_patisserie_id',
        'retour',
        'restant',
        'quantite',
    ];

    public function article(): BelongsTo
    {
        return $this->belongsTo(Article::class);
    }

    public function prodPatisserie(): BelongsTo
    {
        return $this->belongsTo(ProdPatisserie::class);
    }

    public function nombreVerser(): int
    {
        return ($this->quantite - $this->restant - $this->retour);
    }
    public function montantAVerser(): int
    {
        return ($this->quantite - $this->restant - $this->retour) * $this->article->prix;
    }
    public function getNombreVerserAttribute(): int
    {
        return $this->nombreVerser();
    }
    public function getMontantAVerserAttribute(): int
    {
        return $this->montantAVerser();
    }
    protected $appends = ['nombre_verser', 'montant_a_verser'];


}


Boulangerie.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasManyThrough;
use Psr\Container\ContainerExceptionInterface;
use Psr\Container\NotFoundExceptionInterface;

class Boulangerie extends Model
{
    use HasFactory;
    protected $fillable = ["nom","company_id","prix_pain_livreur","prix_pain_client","boulangerie_id"];

    /**
     * @throws ContainerExceptionInterface
     * @throws NotFoundExceptionInterface
     * @throws \Exception
     */
    public static function requireBoulangerieOfLoggedInUser(): Boulangerie
    {
        if (app()->runningUnitTests()) {
            return Boulangerie::factory()::mockActiveBoulangerie();
        }
        // if it is admin user we check is there is  active boulangerie_id in session data
        $user = auth()->user();
        if ($user === null) {

            throw new \Exception('User not logged in');

        }
        $is_admin = $user->is_admin;
        if ($is_admin) {
            $boulangerie_id = request()->header('ACTIVE-BOULANGERIE-ID');

            if ($boulangerie_id) {
                return Boulangerie::findOrFail($boulangerie_id);
            }else{
                // get company of user
                $company = CompanyUser::where('user_id',$user->id)->firstOrFail()->company;
                return $company->boulangeries->firstOrFial();
            }
        }else{
            // get boulangrie of user
            return BoulangerieUser::where('user_id',$user->id)->firstOrFail()->boulangerie;

        }

    }

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }
    public function caisses(): HasMany
    {
        return $this->hasMany(Caisse::class);
    }
    public function chariots(): HasMany
    {
        return $this->hasMany(Chariot::class);
    }
    public function clients(): HasMany
    {
        return $this->hasMany(Client::class);
    }

    public function boutiques(): HasMany
    {
        return $this->hasMany(Boutique::class);
    }
    public function abonnements(): HasManyThrough
    {
        return $this->hasManyThrough(Abonnement::class, Client::class);

    }
    public function livreurs(): HasMany
    {
        return $this->hasMany(Livreur::class);
    }

    public function versements(): HasMany
    {
        return $this->hasMany(Versement::class);
    }
    public function typeDepenses(): HasMany
    {
        return $this->hasMany(TypeDepense::class);
    }
    public function typeRecettes(): HasMany
    {
        return $this->hasMany(TypeRecette::class);
    }
    public function recettes(): HasMany
    {
        return $this->hasMany(Recette::class);
    }



}


BoulangerieUser.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class BoulangerieUser extends Model
{
    use HasFactory;
    protected $fillable = [
        'boulangerie_id',
        'user_id',
    ];
    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
}


Boutique.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Boutique extends Model
{
    use BoulangerieScope;
    use HasFactory;
    protected $fillable = ["nom", "boulangerie_id", "solde_pain", "adresse"];
    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }
    public function identifier(): string
    {
        return  $this->nom;

    }
}


Caisse.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Support\Facades\DB;

/**
 * @property int $solde
 */
class Caisse extends Model
{
    use BoulangerieScope;

    use HasFactory;

    protected $fillable = ["nom", "solde","boulangerie_id"
    ];

    public static function requireCaisseOfLoggedInUser(): Caisse
    {
        $boulangerie = Boulangerie::requireBoulangerieOfLoggedInUser();
        return $boulangerie->caisses()->firstOrFail();
    }

    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }
    public function transactions(): HasMany
    {
        return $this->hasMany(CaisseTransaction::class);
    }
    public function identifier() : string
    {
        return strtoupper($this->nom). ' : '.$this->boulangerie->nom.', solde:  ' . $this->solde;
    }

    public function augmenterSolde(int $montant, array $metadata = []): self
    {
        $this->solde += $montant;
        DB::transaction(function () use ($montant, $metadata) {
            $this->save();
            $this->saveTransaction('cashin',$montant,$this->solde - $montant, $metadata);
        });

        return  $this;
    }
    public function diminuerSolde(int $montant, array $metadata = []): self
    {
        $solde_avant = (int)$this->solde;
        $this->solde -= $montant;
        DB::transaction(function () use ($montant,$solde_avant, $metadata) {
            $this->save();
            $this->saveTransaction('cashout',$montant,($solde_avant), $metadata);
        });

        return  $this;
    }

    public function getSoldeCaisseAtDateTime(\DateTime $dateTime): int
    {
        return $this->transactions()
            ->whereDate('created_at', '<=', $dateTime->format('Y-m-d'))->latest()->first()->solde_apres ?? 0;
    }
    protected function saveTransaction($type,$montant,$solde_avant,array $metadata): self
    {
        $transaction = new CaisseTransaction($metadata);
        $transaction->type = $type;
        $transaction->commentaire = $metadata['commentaire'] ?? null;
        $transaction->metadata = $metadata['metadata'] ?? [];
        $transaction->montant = $montant;
        $transaction->solde_avant = $solde_avant;
        $transaction->solde_apres = $this->solde;
        $this->transactions()->save($transaction);
        return $this;
    }
    public function recettes() : HasMany
    {
        return $this->hasMany(Recette::class);
    }
    public function depenses() : HasMany
    {
        return $this->hasMany(Depense::class);
    }

}


CaisseTransaction.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class CaisseTransaction extends Model
{
    use HasFactory;
    protected $fillable =["caisse_id",
    "type",
    "montant",
    "commentaire",
    "user_id",
    "solde_avant",
    "solde_apres",
    "metadata"];

    public function caisse(): BelongsTo
    {
        return $this->belongsTo(Caisse::class);
    }
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
    protected $casts = [
        'metadata' => 'array'
    ];
}


CategorieOuvrier.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class CategorieOuvrier extends Model
{
    use HasFactory;
}


Chariot.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Chariot extends Model
{
    use BoulangerieScope;

    use HasFactory;
    protected $fillable = ["nom","nombre_pain","boulangerie_id"];

    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }
    public function identifier(): string
    {
        return "Chariot ".$this->nombre_pain." pains";
    }
}


ChariotProdPanetier.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class ChariotProdPanetier extends Model
{
    use HasFactory;
    protected $table = 'chariot_prod_panetiers';
    protected $fillable = ['production_panetier_id', 'chariot_id',"nombre"];
    public function productionPanetier(): BelongsTo
    {
        return $this->belongsTo(ProductionPanetier::class);
    }
    public function chariot(): BelongsTo
    {
        return $this->belongsTo(Chariot::class);
    }
}


ChariotProdPetrisseur.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class ChariotProdPetrisseur extends Model
{
    use HasFactory;
    protected $fillable = [
        'chariot_id',
        'production_petrisseur_id',
        'nombre'
    ];
    public function chariot(): BelongsTo
    {
        return $this->belongsTo(Chariot::class);
    }
    public function productionPetrisseur(): BelongsTo
    {
        return $this->belongsTo(ProductionPetrisseur::class);
    }
}


Client.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasOne;

class Client extends Model
{
    use HasFactory;
    use BoulangerieScope;

    protected $fillable = [
        'prenom',
        'nom',
        "boulangerie_id",
        'is_active',
        'telephone',
    ];
    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);

    }
    public function compteClient(): HasOne
    {
        return $this->HasOne(CompteClient::class);
    }
    public function abonnement(): HasOne
    {
        return $this->HasOne(Abonnement::class);
    }
    public function identifier() : string
    {
        return strtoupper($this->prenom . ' ' . $this->nom . ' : ' ). $this->telephone;
    }
}


Company.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Company extends Model
{
    use HasFactory;

    /**
     * @throws \Exception
     */
    public static function requireCompanyOfLoggedInUser()
    {
        $user = auth()->user();
        if ($user === null) {
            if (app()->runningUnitTests()) {
                return Company::first()??Company::factory()->create();

            }
            throw new \Exception('Require company of logged in user failed, User not logged in');
        }
        // find company
        return CompanyUser::where('user_id',$user->id)->firstOrFail()->company;
    }

    public function boulangeries(): HasMany
    {
        return $this->hasMany(Boulangerie::class);
    }

}


CompanyUser.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class CompanyUser extends Model
{
    use HasFactory;

    protected $fillable = [
        'company_id',
        'user_id',
    ];
    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
}


CompteClient.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class CompteClient extends Model
{
    use HasFactory;
    protected $fillable = [
        'solde_pain',
        'dette',
        'solde_reliquat',
    ];
    public function client(): BelongsTo
    {
        return $this->belongsTo(Client::class);
    }
}


CompteLivreur.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class CompteLivreur extends Model
{
    use HasFactory;
    protected $fillable = [
        'solde_pain',
        'dette',
        'solde_reliquat',
    ];
    public function livreur(): BelongsTo
    {
        return $this->belongsTo(Livreur::class);
    }
    public function augmenterSoldePain(int $nombre_pain): self
    {
        $this->solde_pain += $nombre_pain;
        return $this;
    }
    public function diminuerSoldePain(int $nombre_pain): self
    {
        $this->solde_pain -= $nombre_pain;
        return $this;
    }
    public function augmenterDette(int $dette): self
    {
        $this->dette += $dette;
        return $this;
    }
    public function diminuerDette(int $dette): self
    {
        $this->dette -= $dette;
        return $this;
    }
    public function augmenterSoldeReliquat(int $solde_reliquat): self
    {
        $this->solde_reliquat += $solde_reliquat;
        return $this;
    }
    public function diminuerSoldeReliquat(int $solde_reliquat): self
    {
        $this->solde_reliquat -= $solde_reliquat;
        return $this;
    }
    public function getSoldePainAttribute() : int
    {
       return $this->livreur->distribPanetiers()->where('versement_id', null)->sum('nombre_pain');

    }
    public function getDetteAttribute() : int
    {
        return $this->livreur->distribPanetiers()
            ->where('versement_id', null)->sum('nombre_pain') * $this->livreur->prix_pain;
    }
}


Depense.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Depense extends Model
{
    use HasFactory;
    use BoulangerieScope;


    protected $fillable = [
        'type_depense_id',
        'montant',
        'commentaire',
        'caisse_id'
    ];
    public function typeDepense(): BelongsTo
    {
        return $this->belongsTo(TypeDepense::class);

    }

    public function caisse(): BelongsTo
    {
        return $this->belongsTo(Caisse::class);
    }
    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }
}


DistribPanetier.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Support\HigherOrderCollectionProxy;

/**
 * @property $nombre_retour
 */
class DistribPanetier extends Model
{
    use HasFactory;

    protected $fillable = [
        "nombre_pain",
        "livreur_id",
        "client_id",
        "boutique_id",
        "abonnement_id",
        "production_panetier_id",
        "bonus",
        'nombre_retour',
        "versement_id"
    ];
    public function livreur(): BelongsTo
    {
        return $this->belongsTo(Livreur::class);

    }
    public function client(): BelongsTo
    {
        return $this->belongsTo(Client::class);
    }
    public function boutique(): BelongsTo
    {
        return $this->belongsTo(Boutique::class);
    }
    public function abonnement(): BelongsTo
    {
        return $this->belongsTo(Abonnement::class);
    }
    public function productionPanetier(): BelongsTo
    {
        return $this->belongsTo(ProductionPanetier::class);
    }
    public function versement(): BelongsTo
    {
        return $this->belongsTo(Versement::class);
    }
    public function isForLivreur(): bool
    {
        return $this->livreur_id !== null;
    }
    public function isForClient(): bool
    {
        return $this->client_id !== null;
    }
    public function isForBoutique(): bool
    {
        return $this->boutique_id !== null;
    }

    public function isForAbonnement(): bool
    {
        return $this->abonnement_id !== null;
    }

    public function valeurPain(): int
    {
        if ($this->isForLivreur()) {
            $prix_pain = $this->livreur->prix_pain;
        }
        else{
            $prix_pain = Boulangerie::requireBoulangerieOfLoggedInUser()->prix_pain_livreur;
        }
        return ($this->attributes['nombre_pain'] - $this->attributes['nombre_retour'])* $prix_pain;
    }
}


Intrant.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;

class Intrant extends Model
{
    use HasFactory;
    use BoulangerieScope;

    protected $fillable = ["nom"];

    public function stock(): HasOne
    {
        return $this->hasOne(StockIntrant::class);
    }

    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }

}


Livreur.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;

class Livreur extends Model
{
    use HasFactory;
    use BoulangerieScope;
    protected $fillable = [
        'prenom',
        'nom',
        'telephone',
        'boulangerie_id',
        'prix_pain',
        "is_active"
    ];
    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }
    public function compteLivreur(): HasOne
    {
        return $this->HasOne(CompteLivreur::class);
    }
    public function versements() : HasMany
    {
        return $this->hasMany(Versement::class);

    }
    public function distribPanetiers() : HasMany
    {
        return $this->hasMany(DistribPanetier::class);
    }
    public function identifier() : string
    {
        return strtoupper($this->prenom . ' ' . $this->nom . ' : ' ). $this->telephone;

    }

    public function getPrixPainAttribute() : int
    {
        if ($this->attributes['prix_pain'] == null || $this->attributes['prix_pain'] == 0) {
            return $this->boulangerie->prix_pain_livreur;
        }
        return $this->attributes['prix_pain'];

    }
}


MouveIntrant.php
<?php
/**
 * @noinspection PhpUnused
 */

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class MouveIntrant extends Model
{
    use BoulangerieScope;

    protected $fillable  = ["stock_intrant_id", "boulangerie_id", "quantite", "stock_avant", "stock_apres", "type", "metadata"];
    use HasFactory;

    public function stockIntrant(): BelongsTo
    {
        return $this->belongsTo(StockIntrant::class);
    }
    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }

    protected $casts = ["metadata" => 'array'];
}


Ouvrier.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Ouvrier extends Model
{
    use HasFactory;
    use BoulangerieScope;

}


ProdPatisserie.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class ProdPatisserie extends Model
{
    use HasFactory;
    use BoulangerieScope;

    protected $fillable = [
        'date_production',
        'boulangerie_id',
        'verse',
        'restant_transfere',
        'periode'
    ];
    protected $casts = [
        'verse' => 'boolean',
        'restant_transfere' => 'boolean'
    ];
    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }


    public function articles(): HasMany
    {
        return $this->hasMany(ArticleProdPatisserie::class);
    }

    /** @noinspection PhpUnused */
    public function getNombreAVerserAttribute(): int
    {
        return $this->articles->sum('nombre_verser');
    }
    /** @noinspection PhpUnused */
    public function getMontantAVerserAttribute(): int
    {
        return $this->articles->sum('montant_a_verser');
    }


    protected $appends = ['nombre_a_verser', 'montant_a_verser'];

}


ProductionPanetier.php
<?php
/**
 * @noinspection PhpUnused

 */
namespace App\Models;

use App\Traits\BoulangerieScope;
use Carbon\Carbon;
use Carbon\Exceptions\InvalidFormatException;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class ProductionPanetier extends Model
{
    use HasFactory;
    use BoulangerieScope;

    protected $fillable = [
        'date_production',
        'nombre_pain',
        'nombre_plat',
        'nombre_sac',
        "boulangerie_id",
        "ration",
        "donation",
        "casse", "mange",
        "prix_pain_client",
        "periode",
        "prix_pain_livreur",
        'ration',
        'donation',
        'casse',
        'mange',
        'periode',
        'boulangerie_id',
        'production_petrisseur_id'
    ];

    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);

    }

    /**
     * @return HasMany
     */
    public function chariots(): HasMany
    {
        return $this->hasMany(ChariotProdPanetier::class, 'production_panetier_id');

    }

    public function distribPanetiers(): HasMany
    {
        return $this->hasMany(DistribPanetier::class);
    }
    public function getTotalPainPetrisseurProduitAttribute()
    {
        $prod = ProductionPetrisseur::whereId($this->production_petrisseur_id)->first();
        return $prod !== null ? $prod->totalPain : 0;

    }

    /** @noinspection UnknownColumnInspection */
    public function getNombrePainEntregistreAttribute()
    {
        $nombre_pain_plat = $this->nombre_plat;
        return $this->chariots()
                ->selectRaw('SUM(chariot_prod_panetiers.nombre * chariots.nombre_pain) as total_nombre_pain')
                ->join('chariots', 'chariots.id', '=', 'chariot_prod_panetiers.chariot_id')
                ->where('chariot_prod_panetiers.production_panetier_id', $this->id)
                ->value('total_nombre_pain')+ $nombre_pain_plat;
    }
    public  function getTotalPainDistribueAttribute()
    {
        return $this->distribPanetiers()->sum('nombre_pain')
            + $this->casse + $this->donation + $this->mange + $this->ration;
    }

    public function identifier(): string
    {
        return 'Cahier Panetier '.strtoupper($this->periode).' du ' . $this->getDateProductionAttribue();

    }

    public function getDateProductionAttribue(): string
    {
        try {
            return Carbon::parse($this->date_production)->format('d-m-Y');
        } catch (InvalidFormatException $e) {
            return $this->date_production;
        }

    }

    public function productionPetrisseur(): BelongsTo
    {
        return $this->belongsTo(ProductionPetrisseur::class);

    }
    // get nombre pain attribute from total pain petrisseur produit
    public function getNombrePainAttribute()
    {
        return $this->getTotalPainPetrisseurProduitAttribute();
    }
    protected $appends = ['nombre_pain_entregistre', 'total_pain_distribue','total_pain_petrisseur_produit'];
}


ProductionPetrisseur.php
<?php
/**
 * @noinspection PhpUnused
 */
namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;

/**
 * @property mixed $date_production
 */
class ProductionPetrisseur extends Model
{
    use BoulangerieScope;
    use HasFactory;
    protected $table ="production_petrisseurs";
    protected $fillable = ["date_production","boulangerie_id","nombre_chariot","nombre_pain","nombre_plat","nombre_sac","rendement"];

    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }
    public function chariots(): HasMany
    {
        return $this->hasMany(ChariotProdPetrisseur::class);
    }

    public function totalPain() : int
    {

        $chariotsNombrePainMultiplied = $this->chariots->map(function ($chariot) {
            return $chariot->nombre * $chariot->chariot->nombre_pain;
        });
        $totalPain = $chariotsNombrePainMultiplied->sum();

        return $totalPain + $this->attributes['nombre_plat'];

    }
    public function getTotalPainAttribute(): int
    {
        return $this->totalPain();
    }

    public function getRendementAttribute(): float
    {
        // get total pain divided by nombre sac without floating point
        try {
            return round($this->totalPain / $this->nombre_sac);
        } catch (\Exception $e) {
            return 0;
        }
    }
    public function getNombreChariotAttribute(): int
    {
        return $this->chariots->map(function ($chariot) {
            return $chariot->nombre;
        })->sum();
    }
    protected $appends = ['total_pain','rendement','nombre_chariot'];

    public function prodPanetier() : HasOne
    {
        return $this->hasOne(ProductionPanetier::class);

    }



}


Recette.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Recette extends Model
{
    use HasFactory;
    use BoulangerieScope;

    protected $fillable = ["montant", "type_recette_id","boulangerie_id","caisse_id","commentaire"];

    public function typeRecette(): BelongsTo
    {
        return $this->belongsTo(TypeRecette::class);
    }

    public function identifier(): string
    {
        return "Recette : {$this->typeRecette->nom}";

    }
    public function getIdentifierAttribute(): string
    {
        return $this->identifier();
    }
    public function caisse(): BelongsTo
    {
        return $this->belongsTo(Caisse::class);
    }
    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }
    protected $appends = ["identifier"];
}


StockIntrant.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Support\Facades\DB;

class StockIntrant extends Model
{
    use HasFactory;
    use BoulangerieScope;

    protected $fillable = ["nom","intrant_id", "boulangerie_id", "quantite", "prix_achat", "code_bar"];

    public function intrant(): BelongsTo
    {
        return $this->belongsTo(Intrant::class);
    }
    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }
    public function augmenterStock(int $quantite): self
    {
        $stock_avant = $this->quantite;
        $this->quantite += $quantite;

        DB::transaction(function () use ($quantite,$stock_avant) {
            $this->save();
            $this->saveMouvement('in', $quantite, $stock_avant);
        });
        return $this;
    }
    public function mouvements() : HasMany
    {
        return $this->hasMany(MouveIntrant::class);

    }
    public function diminuerStock(int $quantite): self
    {
        $stock_avant = $this->quantite;
        $this->quantite -= $quantite;
        DB::transaction(function () use ($quantite,$stock_avant) {
            $this->save();
            $this->saveMouvement('out', $quantite, $stock_avant);
        });
        return $this;
    }
    public function identifier() : string
    {
        return strtoupper($this->intrant->nom). ' : '.$this->quantite;
    }
    // save mouvement intrant
    public function saveMouvement(string $type, int $quantite, int $stock_avant, array $metadata = []): self
    {
        $this->mouvements()->create([
            "type" => $type,
            "quantite" => $quantite,
            "stock_avant" => $stock_avant,
            "stock_apres" => $this->quantite,
            "metadata" => $metadata,
            "boulangerie_id"=>$this->boulangerie_id
        ]);
        return $this;
    }
}


TypeDepense.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class TypeDepense extends Model
{
    use BoulangerieScope;

    use HasFactory;
    protected $fillable = ['nom','boulangerie_id'];
    public $timestamps = false;

    public function depenses(): HasMany
    {
        return $this->hasMany(Depense::class);
    }
    public function boulangerie() : BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }
}


TypeRecette.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class TypeRecette extends Model
{
    use BoulangerieScope;

    use HasFactory;

    const VERSEMENT_LIVREUR = "versement_livreur";
    const VENTE_PATISSERIE = "vente_patisserie";
    const VERSEMENT_CLIENT = 'versement_client';
    const VERSEMENT_BOUTIQUE = 'versement_boutique';
    const VERSEMENT_ABONNEMENT = 'versement_abonnement';
    const VENTE_RESTANT = 'vente_restant';
    protected $fillable = ["nom","is_active",'boulangerie_id'];

    public function recettes(): HasMany
    {
        return $this->hasMany(Recette::class);
    }
   public function boulangerie(): BelongsTo
   {
         return $this->belongsTo(Boulangerie::class);

   }

}


User.php
<?php

namespace App\Models;

// use Illuminate\Contracts\Auth\MustVerifyEmail;
//use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;
//use Spatie\Permission\Traits\HasRoles;

class User extends Authenticatable
{
//    use CrudTrait;
//    use HasRoles;
    use HasApiTokens, HasFactory, Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
        'phone_number',
        'is_admin',
        'is_super_admin',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array<int, string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
            'is_admin' => 'boolean',
            'is_super_admin' => 'boolean',
        ];
    }
    public function isSuperAdmin(): bool
    {
        return $this->attributes['is_super_admin'];

    }
    public function isAdmin():bool
    {
        return $this->attributes['is_admin'];
    }
}


Versement.php
<?php

namespace App\Models;

use App\Traits\BoulangerieScope;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Versement extends Model
{
    use HasFactory;
//    use BoulangerieScope;

    protected $fillable = [
        'nombre_pain_matin',
        'nombre_pain_soir',
        'nombre_retour',
        'compte_data',
        'montant_verse',
        'livreur_id',
        'client_id',
        'boutique_id',
        'abonnement_id',
        'date_versement',
        'prix_unit',
        'boulangerie_id',
        'caisse_id',
    ];
    public function livreur(): BelongsTo
    {
        return $this->belongsTo(Livreur::class);
    }
    public function boulangerie(): BelongsTo
    {
        return $this->belongsTo(Boulangerie::class);
    }
    public function caisse(): BelongsTo
    {
        return $this->belongsTo(Caisse::class);
    }
    public function client(): BelongsTo
    {
        return $this->belongsTo(Client::class);
    }
    public function boutique() : BelongsTo
    {
        return $this->belongsTo(Boutique::class);
    }
    public function abonnement() : BelongsTo
    {
        return $this->belongsTo(Abonnement::class);
    }
    protected $casts = [
        'compte_data' => 'array'
    ];

    public function isForLivreur(): bool
    {
        return $this->livreur_id !== null;
    }
    public function isForClient(): bool
    {
        return $this->client_id !== null;
    }
    public function isForBoutique(): bool
    {
        return $this->boutique_id !== null;
    }
    public function isForAbonnement(): bool
    {
        return $this->abonnement_id !== null;
    }

    public function identifier(): string
    {
        if ($this->isForLivreur()) {
            return $this->livreur->identifier();
        }
        if ($this->isForClient()) {
            return $this->client->identifier();
        }
        if ($this->isForBoutique()) {
            return $this->boutique->identifier();
        }
        if ($this->isForAbonnement()) {
            return $this->abonnement->identifier();
        }
        return 'Versement';
    }

}



Here are my Migrations:
0001_01_01_000000_create_users_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->bigInteger('phone_number')->unique();
            $table->boolean('is_admin')->default(false);
            $table->boolean('is_super_admin')->default(false);
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });

        Schema::create('password_reset_tokens', function (Blueprint $table) {
            $table->string('email')->primary();
            $table->string('token');
            $table->timestamp('created_at')->nullable();
        });

        Schema::create('sessions', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->foreignId('user_id')->nullable()->index();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->longText('payload');
            $table->integer('last_activity')->index();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('users');
        Schema::dropIfExists('password_reset_tokens');
        Schema::dropIfExists('sessions');
    }
};


0001_01_01_000001_create_cache_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('cache', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->mediumText('value');
            $table->integer('expiration');
        });

        Schema::create('cache_locks', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->string('owner');
            $table->integer('expiration');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('cache');
        Schema::dropIfExists('cache_locks');
    }
};


0001_01_01_000002_create_jobs_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('jobs', function (Blueprint $table) {
            $table->id();
            $table->string('queue')->index();
            $table->longText('payload');
            $table->unsignedTinyInteger('attempts');
            $table->unsignedInteger('reserved_at')->nullable();
            $table->unsignedInteger('available_at');
            $table->unsignedInteger('created_at');
        });

        Schema::create('job_batches', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->string('name');
            $table->integer('total_jobs');
            $table->integer('pending_jobs');
            $table->integer('failed_jobs');
            $table->longText('failed_job_ids');
            $table->mediumText('options')->nullable();
            $table->integer('cancelled_at')->nullable();
            $table->integer('created_at');
            $table->integer('finished_at')->nullable();
        });

        Schema::create('failed_jobs', function (Blueprint $table) {
            $table->id();
            $table->string('uuid')->unique();
            $table->text('connection');
            $table->text('queue');
            $table->longText('payload');
            $table->longText('exception');
            $table->timestamp('failed_at')->useCurrent();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('jobs');
        Schema::dropIfExists('job_batches');
        Schema::dropIfExists('failed_jobs');
    }
};


2024_07_09_0000003_create_companies_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('companies', function (Blueprint $table) {
            $table->id();
            $table->string('nom')->unique();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('companies');
    }
};


2024_07_09_000004_create_boulangeries_table.php
<?php

use App\Models\Company;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('boulangeries', function (Blueprint $table) {
            $table->id();
            $table->string('nom')->nullable(false);
            $table->integer('prix_pain_livreur')->nullable(false)->default(145);
            $table->integer('prix_pain_client')->nullable(false)->default(150);
            $table->foreignIdFor(Company::class)->constrained()->cascadeOnDelete();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('boulangeries');
    }
};


2024_07_09_122748_create_livreurs_table.php
<?php

use App\Models\Boulangerie;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateLivreursTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up(): void
    {
        Schema::create('livreurs', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(Boulangerie::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->string('prenom');
            $table->string('nom');
            $table->string('telephone');
            $table->integer('prix_pain')->default(140);
            $table->boolean('is_active')->default(true);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down(): void
    {
        Schema::dropIfExists('livreurs');
    }
}


2024_07_09_140141_create_production_petrisseurs_table.php
<?php

use App\Models\Boulangerie;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('production_petrisseurs', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(Boulangerie::class);
            $table->date('date_production')->nullable(false)
                ->unique()
                ->default(today()->toDateString());
            $table->integer('nombre_sac');
            $table->integer('nombre_chariot')->default(0);
            $table->integer('nombre_plat')->default(0);
            $table->integer('nombre_pain')->default(0);
            $table->integer('rendement')->default(0);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('production_petrisseurs');
    }
};


2024_07_09_140142__production_pantier_table.php
<?php

use App\Models\Boulangerie;
use App\Models\ProductionPetrisseur;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up(): void
    {
        Schema::create('production_panetiers', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(Boulangerie::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->date('date_production');
            $table->integer('nombre_pain');
            $table->integer('nombre_plat');
            $table->integer('nombre_sac');
            $table->integer('ration')->default(0);
            $table->integer('donation')->default(0);
            $table->integer('casse')->default(0);
            $table->integer('mange')->default(0);
            $table->integer('prix_pain_client')->default(120);
            $table->enum('periode', ['matin', 'soir']);
            $table->unique(['boulangerie_id','date_production', 'periode'], 'unique_production_panetier');
            $table->integer('prix_pain_livreur')->default(150);
            $table->foreignIdFor(ProductionPetrisseur::class)->nullable()->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down(): void
    {
        Schema::dropIfExists('production_panetier');
    }
};



2024_07_09_143202_create_ouvriers_table.php
<?php

use App\Models\CategorieOuvrier;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('ouvriers', function (Blueprint $table) {
            $table->id();
            $table->string('prenom');
            $table->string('nom');
            $table->string('telephone');
            $table->foreignIdFor(CategorieOuvrier::class);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('ouvriers');
    }
};


2024_07_09_143418_create_caisses_table.php
<?php

use App\Models\Boulangerie;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('caisses', function (Blueprint $table) {
            $table->id();
            $table->string('nom');
            $table->foreignIdFor(Boulangerie::class);
            $table->unique(['nom', 'boulangerie_id']);
            $table->integer('solde')->default(0);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('caisses');
    }
};


2024_07_09_144335_create_categories_ouvrier_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('categories_ouvrier', function (Blueprint $table) {
            $table->id();
            $table->string('nom')->unique();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('categories_ouvrier');
    }
};


2024_07_09_144748_create_clients_table.php
<?php

use App\Models\Boulangerie;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateClientsTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up(): void
    {
        Schema::create('clients', function (Blueprint $table) {
            $table->id();
            $table->string('prenom');
            $table->string('nom');
            $table->string('telephone');
            $table->boolean('is_active')->default(true);
            $table->timestamps();
            $table->foreignIdFor(Boulangerie::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down(): void
    {
        Schema::dropIfExists('clients');
    }
}


2024_07_09_153201_create_type_depenses_table.php
<?php

use App\Models\Boulangerie;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('type_depenses', function (Blueprint $table) {
            $table->id();
            $table->string('nom')->nullable(false);
            $table->string('constant_name')->nullable();
            $table->unique(['constant_name',"boulangerie_id"]);
            $table->unique(['nom', 'boulangerie_id']);

            $table->foreignIdFor(Boulangerie::class)->constrained()->cascadeOnDelete();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('type_depenses');
    }
};


2024_07_09_153202_create_depenses_table.php
<?php

use App\Models\Boulangerie;
use App\Models\Caisse;
use App\Models\TypeDepense;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('depenses', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(TypeDepense::class)->nullable()->constrained()->nullOnDelete();
            $table->foreignIdFor(Boulangerie::class)->nullable(false)->constrained()->cascadeOnDelete();
            $table->foreignIdFor(Caisse::class)->nullable(false)->constrained()->cascadeOnDelete();
            $table->integer('montant')->nullable(false);
            $table->string('commentaire')->nullable();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('depenses');
    }
};


2024_07_09_164404_create_intrants_table.php
<?php

use App\Models\Boulangerie;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('intrants', function (Blueprint $table) {
            $table->id();
            $table->string('nom')->nullable(false);
            $table->foreignIdFor(Boulangerie::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->string('constant_name')->nullable();
            $table->unique(['constant_name',"boulangerie_id"]);
            $table->unique(['nom',"boulangerie_id"]);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('intrants');
    }
};


2024_07_09_164404_create_stock_intrants_table.php
<?php

use App\Models\Boulangerie;
use App\Models\Intrant;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('stock_intrants', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(Intrant::class)->constrained()->cascadeOnDelete();
            $table->string('nom')->nullable(false)->unique(); // add this line
            $table->foreignIdFor(Boulangerie::class);
            $table->integer('code_bar')->nullable();
            $table->integer('quantite')->default(0);
            $table->integer('prix_achat')->default(0);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('stock_intrants');
    }
};


2024_07_09_164404_mouve_intrants_table.php
<?php

use App\Models\Boulangerie;
use App\Models\Intrant;
use App\Models\StockIntrant;
use App\Models\User;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('mouve_intrants', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(StockIntrant::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();;
            $table->foreignIdFor(Boulangerie::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->integer('quantite')->default(0);
            $table->integer('stock_avant');
            $table->integer('stock_apres');
            $table->enum('type', ['in', 'out']);
            $table->json('metadata')->nullable();
            $table->foreignIdFor(User::class)->nullable();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('stock_intrants');
    }
};


2024_07_12_113724_create_chariots_table.php
<?php

use App\Models\Boulangerie;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('chariots', function (Blueprint $table) {
            $table->id();
            $table->string('nom');
            $table->unique(['nom','boulangerie_id']);
            $table->integer('nombre_pain')->default(0);
            $table->foreignIdFor(Boulangerie::class);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('chariots');
    }
};


2024_07_12_115252_create_chariot_prod_panetiers_table.php
<?php

use App\Models\Chariot;
use App\Models\ProductionPanetier;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('chariot_prod_panetiers', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(ProductionPanetier::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->integer('nombre')->nullable(false);
            $table->foreignIdFor(Chariot::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('chariot_prod_panetiers');
    }
};


2024_07_12_115319_create_chariot_prod_petrisseurs_table.php
<?php

use App\Models\Chariot;
use App\Models\ProductionPanetier;
use App\Models\ProductionPetrisseur;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('chariot_prod_petrisseurs', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(ProductionPetrisseur::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->foreignIdFor(Chariot::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->integer('nombre');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('chariot_prod_petrisseurs');
    }
};


2024_07_16_113034_create_boutiques_table.php
<?php

use App\Models\Boulangerie;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('boutiques', function (Blueprint $table) {
            $table->id();
            $table->string('nom')->nullable(false);
            $table->foreignIdFor(Boulangerie::class);
            $table->unique(['nom', 'boulangerie_id']);
            $table->string('solde_pain')->nullable();
            $table->string('adresse')->nullable();

            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('boutiques');
    }
};


2024_07_16_113852_create_abonnements_table.php
<?php

use App\Models\Client;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('abonnements', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(Client::class)->nullable(false)->constrained()->cascadeOnDelete()
                ->cascadeOnUpdate();
            $table->dateTime('date_debut')->nullable(false)->default(today()->toDateTimeString());
            $table->dateTime('date_fin')->nullable(false)->default(today()->addMonth()->toDateTimeString());
            $table->integer('solde_pain')->default(0);
            $table->integer('dette')->default(0);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('abonnements');
    }
};


2024_07_16_115127_create_compte_livreurs_table.php
<?php

use App\Models\Livreur;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('compte_livreurs', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(Livreur::class);
            $table->integer('solde_pain')->default(0);
            $table->integer('dette')->default(0);
            $table->integer('solde_reliquat')->default(0);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('compte_livreurs');
    }
};


2024_07_16_115425_create_compte_clients_table.php
<?php

use App\Models\Client;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('compte_clients', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(Client::class);
            $table->integer('solde_pain')->default(0);
            $table->integer('dette')->default(0);
            $table->integer('solde_reliquat')->default(0);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('compte_clients');
    }
};


2024_07_18_233446_create_caisse_transactions_table.php
<?php

use App\Models\Caisse;
use App\Models\User;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('caisse_transactions', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(Caisse::class)->constrained()->cascadeOnUpdate()->cascadeOnDelete();
            $table->enum('type', ['cashin', 'cashout']);
            $table->integer('montant')->nullable(false);
            $table->string('commentaire')->nullable();
            $table->foreignIdFor(User::class)->nullable()->constrained()->cascadeOnUpdate()->cascadeOnDelete();
            $table->integer('solde_avant')->nullable(false);
            $table->integer('solde_apres')->nullable(false);
            $table->json('metadata')->nullable();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('caisse_transactions');
    }
};


2024_07_19_122753_create_versements_table.php
<?php
/** @noinspection PhpUnused */

use App\Models\Abonnement;
use App\Models\Boulangerie;
use App\Models\Boutique;
use App\Models\Caisse;
use App\Models\Client;
use App\Models\Livreur;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class  extends Migration {
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up(): void
    {
        Schema::create('versements', function (Blueprint $table) {
            $table->id();
            $table->integer('nombre_pain_matin')->default(0);
            $table->integer('nombre_pain_soir')->default(0);
            $table->integer('nombre_retour')->default(0);
            $table->integer('montant_verse')->default(0);
            $table->foreignIdFor(model: Livreur::class)->nullable()->constrained()->onDelete('set null')->cascadeOnUpdate();
            $table->foreignIdFor(model: Client::class)->nullable()->constrained()->onDelete('set null')->cascadeOnUpdate();
            $table->foreignIdFor(model: Boutique::class)->nullable()->constrained()->onDelete('set null')
                ->cascadeOnUpdate();
            $table->foreignIdFor(model: Abonnement::class)->nullable()->constrained()->onDelete('set null')
                ->cascadeOnUpdate();
            $table->date('date_versement')->nullable(false);
            $table->integer('prix_unit')->default(0);
            $table->json('compte_data')->nullable();
            $table->foreignIdFor(Boulangerie::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->foreignIdFor(Caisse::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down(): void
    {
        Schema::dropIfExists('cahier_livreurs');
    }
};


2024_07_19_153221_create_distrib_panetier_table.php
<?php

use App\Models\Abonnement;
use App\Models\Boutique;
use App\Models\Client;
use App\Models\Livreur;
use App\Models\ProductionPanetier;
use App\Models\Versement;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateDistribPanetierTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up(): void
    {
        Schema::create('distrib_panetiers', function (Blueprint $table) {
            $table->id();
            $table->integer('nombre_pain');
            $table->integer('bonus')->nullable();
            $table->foreignIdFor(Livreur::class)->nullable()->constrained()->onDelete('set null');
            $table->foreignIdFor(Client::class)->nullable()->constrained()->onDelete('set null');
            $table->foreignIdFor(Boutique::class)->nullable()->constrained()->onDelete('set null');
            $table->foreignIdFor(Abonnement::class)->nullable()->constrained()->onDelete('set null');
            $table->foreignIdFor(Versement::class)->nullable()->constrained()->onDelete('set null');
            $table->integer('nombre_retour')->default(0);
            $table->timestamps();
            $table
                ->foreignIdFor(ProductionPanetier::class)
                ->nullable(false)
                ->constrained()
                ->onDelete('cascade');
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down(): void
    {
        Schema::dropIfExists('distrib_panetier');
    }
}


2024_07_19_212040_create_type_recettes_table.php
<?php

use App\Models\Boulangerie;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('type_recettes', function (Blueprint $table) {
            $table->id();
            $table->string('nom')->nullable(false);
            $table->string('constant_name')->nullable();
            $table->unique(['constant_name',"boulangerie_id"]);

            $table->foreignIdFor(Boulangerie::class)->constrained()->cascadeOnDelete();
            $table->unique(['nom', 'boulangerie_id']);
            $table->boolean('is_active')->default(true);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('type_recettes');
    }
};


2024_07_19_212042_create_recettes_table.php
<?php

use App\Models\Boulangerie;
use App\Models\Caisse;
use App\Models\TypeRecette;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('recettes', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(Boulangerie::class)->constrained()->cascadeOnDelete();
            $table->integer('montant')->nullable(false);
            $table->foreignIdFor(Caisse::class)->constrained()->cascadeOnDelete();
            $table->text('commentaire')->nullable();
            $table->foreignIdFor(TypeRecette::class)->nullable()->constrained()->onDelete('set null');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('recettes');
    }
};


2024_07_25_154146_create_articles_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('articles', function (Blueprint $table) {
            $table->id();
            $table->string('nom')->nullable(false);
            $table->integer('prix');
            $table->foreignIdFor(\App\Models\Boulangerie::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->unique(['nom', 'boulangerie_id']);
            $table->softDeletes();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('articles');
    }
};


2024_07_25_162304_create_prod_patisseries_table.php
<?php

use App\Models\Boulangerie;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateProdPatisseriesTable extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {/**/
        Schema::create('prod_patisseries', function (Blueprint $table) {
            $table->id();
            $table->date('date_production');
            $table->enum('periode', ['matin', 'soir']);
            $table->foreignIdFor(Boulangerie::class)
                ->constrained()
                ->cascadeOnDelete()
                ->cascadeOnUpdate();
            $table->boolean('restant_transfere')->default(false);
            $table->unique(['date_production','periode', 'boulangerie_id']);
            $table->boolean('verse')->default(false);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('prod_patisseries');
    }
}


2024_07_25_162328_create_article_prod_patisseries_table.php
<?php

use App\Models\Article;
use App\Models\ProdPatisserie;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateArticleProdPatisseriesTable extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('article_prod_patisseries', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(Article::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->foreignIdFor(ProdPatisserie::class)->constrained()->cascadeOnDelete()->cascadeOnUpdate();
            $table->integer('quantite');
            $table->integer('retour')->default(0);
            $table->integer('restant')->default(0);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('article_prod_patisseries');
    }
}


2024_09_23_120601_create_company_users_table.php
<?php

use App\Models\Company;
use App\Models\User;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('company_users', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(Company::class);
            $table->foreignIdFor(User::class);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('company_users');
    }
};


2024_09_23_120735_create_boulangerie_users_table.php
<?php

use App\Models\Boulangerie;
use App\Models\User;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('boulangerie_users', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(Boulangerie::class)->constrained()->cascadeOnDelete();
            $table->foreignIdFor(User::class)->constrained()->cascadeOnDelete();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('boulangerie_users');
    }
};


2024_09_23_123542_create_personal_access_tokens_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('personal_access_tokens', function (Blueprint $table) {
            $table->id();
            $table->morphs('tokenable');
            $table->string('name');
            $table->string('token', 64)->unique();
            $table->text('abilities')->nullable();
            $table->timestamp('last_used_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('personal_access_tokens');
    }
};



Here are my Routes:
api.php
<?php

use App\Http\Controllers\AdminController;
use App\Http\Controllers\ArticleController;
use App\Http\Controllers\ClientController;
use App\Http\Controllers\DepenseController;
use App\Http\Controllers\DistribPanetierController;
use App\Http\Controllers\LivreurController;
use App\Http\Controllers\PanetierController;
use App\Http\Controllers\PetrisseurController;
use App\Http\Controllers\IntrantController;
use App\Http\Controllers\ProdPatisserieController;
use App\Http\Controllers\RecetteController;
use App\Http\Controllers\StockController;
use App\Http\Controllers\VersementController;
use App\Http\Middleware\AdminMiddleware;
use App\Models\Caisse;
use App\Models\Chariot;
use App\Models\Depense;
use App\Models\TypeDepense;
use App\Models\TypeRecette;
use Carbon\Carbon;
use Illuminate\Support\Facades\Route;

// login sections
function loginResponse(): Illuminate\Http\Response
{
    $token = request()->user()->createToken("name", [], Carbon::now()->addDay());
    $params = [];

    $roles = [];
//    foreach (request()->user()->roles as $role) {
//        $roles[] = $role->name;
//
//    }
    $permissions = [];
    /*foreach (request()->user()->permissions as $permission) {
        $roles[] = $permission->name;

    }*/
    $user = request()->user();
    return response(["token" => $token, "params" => $params,
        "user" => [
            "email" => $user->email,
            "token" => $token->plainTextToken,
            "tokenExpiresAt" => $token->accessToken->expires_at,
            "name" => $user->name,
            "roles" => $roles,
            "permissions" => $permissions,
            "isAuthenticated" => true,
            "isSuperAdmin" => $user->isSuperAdmin(),
            "is_admin" => $user->isAdmin(),
        ],
        "should_change_password" => (Hash::check("0000", $user->password) || Hash::check("1234", $user->password))
    ]);
}


use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

Route::post('/login', function (Request $request) {
    // Validate phone number and password
    $credentials = $request->validate([
        'phone_number' => ['required'], // Expecting phone number instead of email
        'password' => ['required'],
    ]);

    // Attempt authentication using phone_number and password
    if (Auth::attempt(['phone_number' => $credentials['phone_number'], 'password' => $credentials['password']])) {

        // Validate if user is disabled after authentication
        $request->validate([
            'phone_number' => [function ($attribute, $value, $fail) {
                if (request()->user()->disabled) {
                    $fail("Compte désactivé !");
                    Auth::logout();
                }
            }],
        ]);

        // Call your login response method
        return loginResponse();

    } else {
        // Invalid credentials response
        return response("Invalid credentials")->setStatusCode(401);
    }
});





// Protect routes with sanctum middleware
Route::middleware('auth:sanctum')->group(function () {
    Route::get('production_petrisseur/{date}', [PetrisseurController::class, 'productionDuJour']);
    Route::resource('petrisseurs', PetrisseurController::class);
    Route::get('panetiers/date/{date}', [PanetierController::class, 'productionDuJour']);
    Route::resource('panetiers', PanetierController::class)

        ->parameters([
            'panetiers' => 'productionPanetier',
            // customise the store route
        ]);
    Route::get('distribution_panetiers/destinations', [DistribPanetierController::class, 'getEntitiesForDistrib']);
    Route::get('distribution_panetiers/{productionPanetier}/destinations', [DistribPanetierController::class, 'getEntitiesForDistrib']);
    Route::post('distribution_panetiers/{productionPanetier}', [DistribPanetierController::class, 'store'])->name('distrib-panetier');
    Route::resource('distribution_panetiers', DistribPanetierController::class,[
        'only' => ['index','update','destroy','show']
    ])->parameters([
        'distribution_panetiers' => 'distribPanetier',
        // customise the store route
    ]);
    Route::get('versements/livreurs', [VersementController::class, 'versementsLivreurs'])->name('versements.livreurs');
    Route::get('versements/destinations', [VersementController::class, 'destinations'])->name('versements.destinations');
// versements d'une date
    Route::get('versements/date/{date}', [VersementController::class, 'versementsDate'])->name('versements.date');

// ============= SECTION LIVREURS ====================
    Route::get('/livreurs/{livreur}/historique', [LivreurController::class, 'historique']);
    Route::get('/livreurs/{livreur}/distribution_panetiers', [LivreurController::class, 'getDistribPanetiersOfLivreurs']);

    Route::put('livreurs/{livreur}/activate/{is_active}', [LivreurController::class, 'disable'])->name('livreurs.activate');
    Route::resource('livreurs', LivreurController::class);
    Route::resource('versements', VersementController::class);
    Route::get('depenses/date/{date}', [DepenseController::class, 'depensesDate'])->name('depenses.date');
    Route::resource('depenses', DepenseController::class);
    Route::resource('intrants', IntrantController::class);
    Route::post('stocks/entree',[StockController::class,'entreeStock']);
    Route::post('stocks/sortie/{intrant}',[StockController::class,'sortieStock']);
    Route::get('stocks/movements/{intrant}', [StockController::class, 'getMovements']);
    Route::put('clients/{client}/toggle', [ClientController::class, 'toggle']);

    Route::resource('clients', ClientController::class);

    Route::get('recettes/date/{date}', [RecetteController::class, 'recettesJour']);
    Route::resource('recettes', RecetteController::class);
    Route::get('chariots',function (){
        return response()->json(Chariot::all()->map(function (Chariot $chariot){
            return [
                'id' => $chariot->id,
                'nom' => $chariot->nom,
                "nombre_pain" => $chariot->nombre_pain,
            ];
        }));

    });
    Route::get('types_depenses_recettes',function (){
        return response()->json([
            'type_depenses' => TypeDepense::all()->map(function (TypeDepense $depense){
                return [
                    'id' => $depense->id,
                    'nom' => $depense->nom,
                ];
            }),
            'type_recettes' => TypeRecette::all()->map(function (TypeRecette $recette){
                return [
                    'id' => $recette->id,
                    'nom' => $recette->nom,
                ];
            }),
        ]);
    });
    Route::resource('articles', ArticleController::class);
    Route::delete('production_patisseries/delete_article/{articleProdPatisserie}', [ProdPatisserieController::class,
        'deleteArticle']);

// ================== SECTION PRODUCTION PATISSERIE ====================
    Route::post('production_patisseries/{prodPatisserie}/encaisser', [ProdPatisserieController::class, 'encaisserProdPatisserie']);
    Route::post('production_patisseries/{prod_patisserie}/articles', [ProdPatisserieController::class, 'storeArticles']);
    Route::get('production_patisseries/{prod_patisserie}/articles', [ProdPatisserieController::class, 'getArticles']);
    Route::get('production_patisseries/date/{date}', [ProdPatisserieController::class, 'getProdPatisserieByDate']);
    Route::put('production_patisseries/{prodPatisserie}/articles', [ProdPatisserieController::class, 'updateArticles']);

    Route::resource('production_patisseries', ProdPatisserieController::class)->parameters([
        'production_patisseries' => 'prodPatisserie',
    ]);
// transfert route should accept both get and post requests
    Route::match(['get', 'post'], 'production_patisseries/{prodPatisserie}/transfer', [ProdPatisserieController::class, 'transfer']);

// ================== END SECTION PRODUCTION PATISSERIE ====================

    Route::get('caisse',function (){

        $caisse = Caisse::requireCaisseOfLoggedInUser();
        return response()->json(["solde" => $caisse->solde]);

    });

// admin section routes with 'admin' prefix and protected by admin middleware
    Route::prefix('admin')->group(function () {
        Route::get('boulangeries', [AdminController::class, 'boulangeries']);
        Route::post('boulangeries/change_active', [AdminController::class, 'changeActiveBoulangerie']);
        Route::get('boulangeries/{boulangerie}/dashboard', [AdminController::class, 'dashboard']);
    })->middleware(AdminMiddleware::class);



});

console.php
<?php

use Illuminate\Foundation\Inspiring;
use Illuminate\Support\Facades\Artisan;

Artisan::command('inspire', function () {
    $this->comment(Inspiring::quote());
})->purpose('Display an inspiring quote')->hourly();


web.php
<?php

use Illuminate\Support\Facades\Route;

Route::get('/', function () {
    return view('welcome');
});



Here are my Json Resources:
DistribPanetierResource.php
<?php

namespace App\Http\Resources;

use App\Models\Boulangerie;
use App\Models\DistribPanetier;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class DistribPanetierResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     *
     * @return array<string, mixed>
     */
    public function toArray(Request $request): array
    {
        /** @var $this DistribPanetier */
        $data = [
            "id" => $this->id,
            "nombre_pain" => $this->nombre_pain,

        ];
        if ($this->isForLivreur()) {
            $data["livreur"] = $this->livreur->identifier();
            $data["montant"] = $this->nombre_pain * Boulangerie::requireBoulangerieOfLoggedInUser()->prix_pain_livreur;

        }
        if ($this->isForClient()) {
            $data["client"] = $this->client->identifier();
            $data["montant"] = $this->nombre_pain * Boulangerie::requireBoulangerieOfLoggedInUser()->prix_pain_client;
        }
        if ($this->isForBoutique()) {
            $data["boutique"] = $this->boutique->nom;
            $data["montant"] = $this->nombre_pain * Boulangerie::requireBoulangerieOfLoggedInUser()->prix_pain_client;
        }
        if ($this->isForAbonnement()) {
            $data["abonnement"] = $this->abonnement->identifier();
            $data["montant"] = $this->nombre_pain * Boulangerie::requireBoulangerieOfLoggedInUser()->prix_pain_client;
        }

        return  $data;
    }
}


OperationCaisseResource.php
<?php

namespace App\Http\Resources;

use App\Models\Depense;
use App\Models\Recette;
use App\Models\Versement;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Support\Carbon;

class OperationCaisseResource extends  JsonResource
{
    public function toArray(Request $request): array
    {
        $definition = [
            'id' => $this->id,
            'montant' => $this->montant,
            'created_at' => $this->created_at,
            'commentaire' => $this->commentaire
        ];
        if (isset($this->typeRecette)) {
            $definition['identifier'] = $this->identifier();
            $definition['type_recette_nom'] = $this->typeRecette->nom;
            $definition['type_recette_id'] = $this->typeRecette->id;
        }
        else if (isset($this->typeDepense)) {
            $definition['depense'] = $this->typeDepense->nom;
            $definition['type_depense_nom'] = $this->typeDepense->nom;
            $definition['type_depense_id'] = $this->typeDepense->id;
        }else{
            // throw exception
            throw new \Exception("OperationCaisseResource: OperationCaisseResource must be either Recette or Depense");

        }

        return $definition;
    }
}

ProdPanetierResource.php
<?php

namespace App\Http\Resources;

use App\Models\ChariotProdPanetier;
use App\Models\ProductionPanetier;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class ProdPanetierResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     *
     * @return array<string, mixed>
     */
    public function toArray(Request $request): array
    {
        /** @var $this ProductionPanetier */
        $definition = [
            "id" => $this->id,
            "nombre_petrisseur" => $this->productionPetrisseur() !== null ?
                $this->productionPetrisseur->totalPain : null,
            "date_production" => $this->date_production,
            "identifier" => $this->identifier(),
            "nombre_pain" => $this->nombre_pain,
            "nombre_plat" => $this->nombre_plat,
            "nombre_sac" => $this->nombre_sac,
            "ration" => $this->ration,
            "donation" => $this->donation,
            "casse" => $this->casse,
            "total_pain_petrisseur_produit" => $this->total_pain_petrisseur_produit,
            "nombre_pain_entregistre" => $this->nombre_pain_entregistre,
            "total_pain_distribue" => $this->total_pain_distribue,

            "chariots" => $this->chariots->map(function (ChariotProdPanetier $chariotProdPanetier) {
                return [
                    "nom" => $chariotProdPanetier->chariot->identifier(),
                    "nombre" => $chariotProdPanetier->nombre,
                    "nombre_pain"=> $chariotProdPanetier->chariot->nombre_pain
                ];
            }),
            "mange" => $this->mange,
        ];
        $definition['resultat'] = $definition['nombre_petrisseur'] - $definition['total_pain_distribue'];
        return $definition;
    }
}


VersementResource.php
<?php

namespace App\Http\Resources;

use App\Models\Versement;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Support\Carbon;

class VersementResource extends  JsonResource
{
    public function toArray(Request $request): array
    {
        /** @var $this Versement */
        $data = [
            'id' => $this->id,
            "montant_verse" => $this->montant_verse,
            "nombre_retour" => $this->nombre_retour,
            'created_at' => Carbon::parse($this->created_at)->format('Y-m-d H:i:s'),

        ];
        if ($this->isForLivreur()){
            $data['livreur'] = $this->livreur->identifier();
        }
        if ($this->isForClient()){
            $data['client'] = $this->client->identifier();
        }
        if ($this->isForBoutique()){
            $data['boutique'] = $this->boutique->identifier();
        }
        if ($this->isForAbonnement()){
            $data['abonnement'] = $this->abonnement->identifier();
        }
        $data['caisse'] = $this->caisse->identifier();
        return $data;
    }


}


Here are my Rules:
UniqueProductionPeriode.php
<?php

namespace App\Rules;

use Carbon\Carbon;
use Closure;
use Illuminate\Contracts\Validation\ValidationRule;
use App\Models\ProductionPanetier;

class UniqueProductionPeriode implements ValidationRule
{
    private ?string $date_production;
    private ?string $periode;
    private ?int $excludeId;

    public function __construct($date_production, $periode, $excludeId = null)
    {
        $this->date_production = $date_production;
        $this->periode = $periode;
        $this->excludeId = $excludeId;
    }



    public function message(): string
    {
        return 'On a déjà crée un cahier pantier pour '.$this->periode.' pour la date  '.$this->date_production;
    }

    /**
     * @param string $attribute
     * @param mixed $value
     * @param Closure $fail
     * @return void
     */
    public function validate(string $attribute, mixed $value, Closure $fail): void
    {

        $query = ProductionPanetier::where('date_production', $this->date_production)
            ->where('periode', $this->periode);

        if ($this->excludeId) {
            $query->where('id', '!=', $this->excludeId);
        }
         if($query->exists()){
            $fail($this->message());
         };
    }
}



Here are my Controllers:
AbonnementController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class AbonnementController extends Controller
{
    //
}


AdminController.php
<?php

namespace App\Http\Controllers;

use App\Models\Boulangerie;
use App\Models\Company;
use App\Models\CompteLivreur;
use App\Models\Depense;
use App\Models\DistribPanetier;
use App\Models\ProductionPetrisseur;
use App\Models\Recette;
use App\Models\StockIntrant;
use App\Models\TypeRecette;
use App\Models\Versement;
use Exception;
use Illuminate\Http\Request;

class AdminController extends Controller
{
    //
    /**
     * @throws Exception
     */
    public function boulangeries()
    {
        //  return only the boulangeries of the logged-in user
        $company =  Company::requireCompanyOfLoggedInUser();
        return response()->json($company->boulangeries);
    }
    public function changeActiveBoulangerie(Request $request)
    {
        $request->validate([
            'boulangerie_id' => 'required|exists:boulangeries,id'
        ]);
        // check if boulangeries belongs to current user
        $company = Company::requireCompanyOfLoggedInUser();
        if (!in_array($request->boulangerie_id, $company->boulangeries->pluck('id')->toArray())) {
            return response()->json(['message' => 'Cette boulangerie n\'appartient pas à votre entreprise'], 403);
        }

        $boulangerie = Boulangerie::findOrFail($request->boulangerie_id);
        session()->put('active_boulangerie_id', $boulangerie->id);
        return response()->json('OK');

    }
    public function dashboard(Boulangerie $boulangerie)
    {
        $date = today()->toDateString();
        $totalProduction = 0;
        // calculate total production
        $productions = ProductionPetrisseur::whereBoulangerieId($boulangerie->id)->whereDateProduction($date)
            ->get();
        foreach ($productions as $production) {
            $totalProduction += $production->total_pain;

        }
        $totals = [
            'versementsJour' => (int)$boulangerie->versements()->whereDate('created_at', today())->sum('montant_verse'),
            'totalPain' => (int) $totalProduction,
            'totalRecettes' => (int)Recette::whereBoulangerieId($boulangerie->id)->whereDate('created_at', today())->sum
            ('montant'),
            'totalDepenses' => (int) Depense::whereBoulangerieId($boulangerie->id)->whereDate('created_at', today())
                ->sum('montant'),
            'soldeDetteLivreurs' => (int) CompteLivreur::whereHas('livreur', function ($query) use ($boulangerie) {
                $query->where('boulangerie_id', $boulangerie->id);
            })->sum('dette'),
            'soldeReliquatLivreurs' => (int) CompteLivreur::whereHas('livreur', function ($query) use ($boulangerie) {
                $query->where('boulangerie_id', $boulangerie->id);
            })->sum('solde_reliquat'),
            'soldePainLivreurs' => (int) CompteLivreur::whereHas('livreur', function ($query) use ($boulangerie) {
                $query->where('boulangerie_id', $boulangerie->id);
            })->sum('solde_pain'),
//            'totalVentePatisserie' => $boulangerie->ventesPatisserie()->sum('montant'),
//            'totalVenteBoutiques' => $boulangerie->ventesBoutique()->sum('montant'),
            'totalVentePatisserie' => Recette::whereBoulangerieId($boulangerie->id)
                ->whereDate('created_at', $date)
                ->whereHas('typeRecette', function ($query) use ($boulangerie) {
                    $query->whereTypeRecetteId(TypeRecette::whereBoulangerieId($boulangerie->id)->where('constant_name', TypeRecette::VENTE_PATISSERIE)->first()?->id);
                })->sum('montant'),
            'totalVenteBoutiques' => Versement::whereBoulangerieId($boulangerie->id)->whereDate('created_at', $date)
                ->whereNotNull('boulangerie_id')->sum('montant_verse'),
            'totalRetoursPain' => (int) Versement::whereBoulangerieId($boulangerie->id)->whereDate('created_at', $date)
                ->whereNotNull('nombre_retour')->sum('nombre_retour'),
            //  calculate total stock using total of quantity of intrants and intrant prix_achat
            // the sum should take total quantity of intrant and multiply by prix_achat of Intrant model using the
            // relation
            "valeurStock" => (int) StockIntrant::select('quantite * prix_achat as total')->whereBoulangerieId($boulangerie->id)->sum('total'),

            'totalVersementsClients' => (int)$boulangerie->versements()->whereNotNull('client_id')->sum('montant_verse'),
            'totalVersementsLivreurs' => (int) $boulangerie->versements()->whereNotNull('livreur_id')->sum('montant_verse'),
        ];

        return response()->json($totals);

    }
}


ArticleController.php
<?php

namespace App\Http\Controllers;

use App\Models\Article;
use App\Models\Boulangerie;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;

class ArticleController extends Controller
{
    /**
     * Display a listing of the articles.
     *
     * @return JsonResponse
     */
    public function index()
    {
        $articles = Article::where('boulangerie_id', Boulangerie::requireBoulangerieOfLoggedInUser()->id)->get();
        return response()->json($articles);
    }

    /**
     * Store a newly created article in storage.
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function store(Request $request)
    {
        $validatedData = $request->validate([
            'nom' => 'required|string|max:255',
            'prix' => 'required|integer',
        ]);

        $article = new Article($validatedData);
        $article->boulangerie_id = Boulangerie::requireBoulangerieOfLoggedInUser()->id;
        $article->save();

        return response()->json($article, 201);
    }

    /**
     * Display the specified article.
     *
     * @param Article $article
     * @return JsonResponse
     */
    public function show(Article $article)
    {
        return response()->json($article);
    }

    /**
     * Update the specified article in storage.
     *
     * @param Request $request
     * @param Article $article
     * @return JsonResponse
     */
    public function update(Request $request, Article $article)
    {
        $validatedData = $request->validate([
            'nom' => 'string|max:255',
            'prix' => 'integer',
        ]);

        $article->update($validatedData);

        return response()->json($article);
    }

    /**
     * Remove the specified article from storage.
     *
     * @param Article $article
     * @return JsonResponse
     */
    public function destroy(Article $article)
    {

        return response()->json(null, 204);
    }
}


BoutiqueController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BoutiqueController extends Controller
{
    //
}


ChariotController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class ChariotController extends Controller
{
    //
}


ClientController.php
<?php

namespace App\Http\Controllers;

use App\Models\Boulangerie;
use App\Models\Client;
use App\Models\CompteClient;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;

class ClientController extends Controller
{
    /**
     * Display a listing of clients.
     *
     * @return JsonResponse
     */
    public function index()
    {
        $clients = Client::all();
        return response()->json($clients);
    }

    /**
     * Store a newly created client in storage.
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function store(Request $request)
    {
        $data = $request->validate([
            'nom' => 'required|string|max:255',
            'prenom' => 'required|string|max:255',
            'telephone' => 'required|string|max:255',
        ]);


        $client = new Client($data);
        $client->boulangerie()->associate(Boulangerie::requireBoulangerieOfLoggedInUser());
        $client->save();
        // create compte client
        $compteClient = new  CompteClient();
        $compteClient->solde_pain = 0;
        $compteClient->solde_reliquat = 0;
        $compteClient->client()->associate($client);
        $compteClient->save();


        return response()->json($client, 201);
    }

    /**
     * Display the specified client.
     *
     * @param Client $client
     * @return JsonResponse
     */
    public function show(Client $client)
    {
        return response()->json($client);
    }

    /**
     * Update the specified client in storage.
     *
     * @param Request $request
     * @param Client $client
     * @return JsonResponse
     */
    public function update(Request $request, Client $client)
    {
        $data = $request->validate([
            'nom' => 'sometimes|required|string|max:255',
            'prenom' => 'sometimes|required|string|max:255',
            'telephone' => 'sometimes|required|string|max:255',
        ]);

        $client->update($data);

        return response()->json($client);
    }

    /**
     * Remove the specified client from storage.
     *
     * @param Client $client
     * @return JsonResponse
     */
    public function destroy(Client $client)
    {
        $client->delete();

        return response()->json(null, 204);
    }

    /**
     * Toggle the active status of the specified client.
     *
     * @param Client $client
     * @return JsonResponse
     */
    public function toggle(Client $client)
    {
        $client->is_active = !$client->is_active;
        $client->save();

        return response()->json($client);
    }
}


CompteLivreurController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class CompteLivreurController extends Controller
{
    //
}


Controller.php
<?php

namespace App\Http\Controllers;

abstract class Controller
{
    //
}


DepenseController.php
<?php

namespace App\Http\Controllers;

use App\Http\Resources\OperationCaisseResource;
use App\Models\Boulangerie;
use App\Models\Caisse;
use App\Models\Depense;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;

class DepenseController extends Controller
{
    /**
     * Display a listing of dépenses.
     *
     * @return JsonResponse
     */
    public function index()
    {
        $depenses = Depense::whereHas("caisse",function (Builder $query){
            $query->where("boulangerie_id", Boulangerie::requireBoulangerieOfLoggedInUser()->id);
        })->get();
        return response()->json(OperationCaisseResource::collection($depenses));
    }

    public function depensesDate($date)
    {
        $depenses =  Depense::whereHas("caisse",function (Builder $query){
            $query->where("boulangerie_id", Boulangerie::requireBoulangerieOfLoggedInUser()->id);
        })->whereDate('created_at',$date)
            ->orderByDesc('created_at')->get();
        return response()->json(OperationCaisseResource::collection($depenses));

    }

    /**
     * Store a newly created dépense in storage.
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function store(Request $request)
    {
        $validatedData = $request->validate([
            'type_depense_id' => 'required|integer|exists:type_depenses,id',
            'montant' => 'required|numeric',
            "commentaire"=>"nullable|string",
            // Add other fields as necessary
        ]);

        $depense = new Depense($validatedData);
        DB::transaction(function () use ($depense) {
            $depense->caisse()->associate(Caisse::requireCaisseOfLoggedInUser());
            $depense->boulangerie()->associate(Boulangerie::requireBoulangerieOfLoggedInUser());
            $depense->save();
            $caisse = $depense->caisse;
            $caisse->diminuerSolde($depense->montant);
            $caisse->save();
        });

        return response()->json($depense, 201);
    }

    /**
     * Display the specified dépense.
     *
     * @param Depense $depense
     * @return JsonResponse
     */
    public function show(Depense $depense)
    {
        return response()->json($depense);
    }

    /**
     * Update the specified dépense in storage.
     *
     * @param Request $request
     * @param Depense $depense
     * @return JsonResponse
     */
    public function update(Request $request, Depense $depense)
    {
        DB::transaction(function () use ($depense,$request) {
            $previousAmount = $depense->montant;
            $validatedData = $request->validate([
                'montant' => 'numeric',
                'type_depense_id' => 'integer|exists:type_depenses,id',
                "commentaire"=>"nullable|string",
            ]);
            $depense->update($validatedData);
            $caisse = $depense->caisse;
            $shouldIncreaseSoldeCaisse = $validatedData['montant'] > $previousAmount;
            $shouldDecreaseSoldeCaisse = $validatedData['montant'] < $previousAmount;
            if ($shouldIncreaseSoldeCaisse){
                $caisse->augmenterSolde($validatedData['montant'] - $previousAmount);
            }else if ($shouldDecreaseSoldeCaisse){
                $caisse->diminuerSolde($previousAmount - $validatedData['montant']);
            }
            $caisse->save();
        });

        return response()->json($depense);
    }

    /**
     * Remove the specified dépense from storage.
     *
     * @param Depense $depense
     * @return JsonResponse
     */
    public function destroy(Depense $depense)
    {
        DB::transaction(function () use ($depense) {
            $caisse = $depense->caisse;
            $caisse->diminuerSolde($depense->montant);
            $depense->delete();
        });


        return response()->json(null, 204);
    }


}

DistribPanetierController.php
<?php

namespace App\Http\Controllers;

use App\Models\Abonnement;
use App\Models\Boulangerie;
use App\Models\Boutique;
use App\Models\Client;
use App\Models\DistribPanetier;
use App\Models\Livreur;
use App\Models\ProductionPanetier;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;

class DistribPanetierController extends Controller
{
    public function store(ProductionPanetier $productionPanetier, Request $request)
    {
        // the request data should have the following fields livreurs array, clients array, abonnements array, boutiques
        // array. The livreurs array should have the following fields: livreur_id, nombre_pain, bonus, the same for
        // clients, abonnements, and boutiques
        $data = $request->validate([
            'livreurs' => 'array',
            'clients' => 'array',
            'abonnements' => 'array',
            'boutiques' => 'array',
            'livreurs.*.livreur_id' => 'required|integer|exists:livreurs,id',
            'livreurs.*.nombre_pain' => 'required|integer',
            'livreurs.*.bonus' => 'required|integer',
            'clients.*.client_id' => 'required|integer|exists:clients,id',
            'clients.*.nombre_pain' => 'required|integer',
            'clients.*.bonus' => 'required|integer',
            'abonnements.*.abonnement_id' => 'required|integer|exists:abonnements,id',
            'abonnements.*.nombre_pain' => 'required|integer',
            'abonnements.*.bonus' => 'required|integer',
            'boutiques.*.boutique_id' => 'required|integer|exists:boutiques,id',
            'boutiques.*.nombre_pain' => 'required|integer',
            'boutiques.*.bonus' => 'required|integer',

        ]);
        // check if the sum of all the pain distributed is equal to the pain produced
        // $data['nombre_pain'] is the sum of livreurs, clients, abonnements, and boutiques in request
        // we must first sum the existing distribPanetiers  in order to take into account the update
        // of the distribPanetier

        // add the 4 values
        $totalPainOfExisting = $productionPanetier->distribPanetiers()
            ->where(function($query) use ($data) {
                $query->whereIn('livreur_id', collect($data['livreurs'])->pluck('livreur_id')->toArray())
                    ->orWhereIn('client_id', collect($data['clients'])->pluck('client_id')->toArray())
                    ->orWhereIn('abonnement_id', collect($data['abonnements'])->pluck('abonnement_id')->toArray())
                    ->orWhereIn('boutique_id', collect($data['boutiques'])->pluck('boutique_id')->toArray());
            })->sum('nombre_pain');
//

        $data['nombre_pain'] =
            collect($data['livreurs'])->sum('nombre_pain') +
            collect($data['clients'])->sum('nombre_pain') +
            collect($data['abonnements'])->sum('nombre_pain') +
            collect($data['boutiques'])->sum('nombre_pain') - $totalPainOfExisting;
        // loop through livreurs and create a distribPanetier for each

        if ($data['nombre_pain'] > $productionPanetier->nombre_pain) {
            return response()->json(["message" => "Le nombre de pain distribué ne peut pas être supérieur au nombre de pain produit"], 422);
        } else if ($data['nombre_pain'] < 0) {
            return response()->json(["message" => "Le nombre de pain distribué ne peut pas être négatif"], 422);
        } else if ($data['nombre_pain'] > ($productionPanetier->nombre_pain_entregistre - $totalPainOfExisting)) {
            return response()->json(["message" => "Pour le total de pain que vous voulez enregistrer le nombre de pain restant est insuffisant !"], 422);
        }
        // start transaction before saving operations
        DB::transaction(function () use ($productionPanetier, $data) {
            $prix_pain_livreur = Boulangerie::requireBoulangerieOfLoggedInUser()->prix_pain_livreur;
            $prix_pain_client = Boulangerie::requireBoulangerieOfLoggedInUser()->prix_pain_client;
            // loop through livreurs and create a distribPanetier for each
            foreach ($data['livreurs'] as $distrib_data) {


                $distribPanetier = $productionPanetier->distribPanetiers()->whereLivreurId($distrib_data['livreur_id'])
                    ->first();
                if ($distribPanetier == null) {
                    $distribPanetier = new DistribPanetier([
                        'livreur_id' => $distrib_data['livreur_id'],
                        'nombre_pain' => $distrib_data['nombre_pain'],
                        'bonus' => $distrib_data['bonus'],
                    ]);
                    $productionPanetier->distribPanetiers()->save($distribPanetier);
                    $livreur = $distribPanetier->livreur;
                    $compte_livreur = $livreur->compteLivreur;
                    $compte_livreur->augmenterSoldePain($distrib_data['nombre_pain']);
                    $compte_livreur->augmenterDette(($distrib_data['nombre_pain'] *
                            $livreur->prix_pain));
                    $compte_livreur->save();
                } else {
                    $oldNombrePain = $distribPanetier->nombre_pain;
                    $distribPanetier->nombre_pain = $distrib_data['nombre_pain'];
                    $distribPanetier->bonus = $distrib_data['bonus'];
                    $distribPanetier->save();
                    // update compte livreur
                    $livreur = $distribPanetier->livreur;
                    $compte_livreur = $livreur->compteLivreur;
                    // we check the difference between the new nombre_pain and the old one
                    $diff = $distrib_data['nombre_pain'] - $oldNombrePain;
                    if ($diff > 0) {
                        $compte_livreur->augmenterSoldePain($diff);
                        $compte_livreur->augmenterDette( ($diff *
                               $livreur->prix_pain));
                    } else if ($diff < 0) {
                        $compte_livreur->diminuerSoldePain(abs($diff));
                        $compte_livreur->diminuerDette((abs($diff) *
                                $livreur->prix_pain));
                    }
                    $compte_livreur->save();
                }

            }
//            $productionPanetier->distribPanetiers()->save($distribPanetier);
            // loop through clients and create a distribPanetier for each
            foreach ($data['clients'] as $client_data) {
                $distribPanetier = $productionPanetier->distribPanetiers()->whereClientId($client_data['client_id'])
                    ->first();
                if ($distribPanetier == null) {
                    $distribPanetier = new DistribPanetier([
                        'client_id' => $client_data['client_id'],
                        'nombre_pain' => $client_data['nombre_pain'],
                    ]);
                    $productionPanetier->distribPanetiers()->save($distribPanetier);
                    $client = Client::find($client_data['client_id']);
                    $compte_client = $client->compteClient;
                    $compte_client->solde_pain += $client_data['nombre_pain'];
                    $compte_client->dette += ($client_data['nombre_pain'] *
                            $prix_pain_client);
                    $compte_client->save();
                } else {
                    $oldNombrePain = $distribPanetier->nombre_pain;
                    $distribPanetier->nombre_pain = $client_data['nombre_pain'];
                    $distribPanetier->bonus = $client_data['bonus'];
                    $distribPanetier->save();
                    $client = Client::find($client_data['client_id']);
                    $compte_client = $client->compteClient;
                    $diff = $client_data['nombre_pain'] - $oldNombrePain;
                    if ($diff > 0) {
                        $compte_client->solde_pain += $diff;
                        $compte_client->dette += ($diff *
                                $prix_pain_client);
                    } else if ($diff < 0) {
                        $compte_client->solde_pain -= abs($diff);
                        $compte_client->dette -= (abs($diff) *
                                $prix_pain_client);
                    }
                    $compte_client->save();
                }

            }
            // loop through abonnements and create a distribPanetier for each
            foreach ($data['abonnements'] as $abonnement_data) {
                $distribPanetier = $productionPanetier->distribPanetiers()->whereAbonnementId($abonnement_data['abonnement_id'])
                    ->first();
                    $abonnement = Abonnement::find($abonnement_data['abonnement_id']);
                if ($distribPanetier == null) {
                    $distribPanetier = new DistribPanetier([
                        'abonnement_id' => $abonnement_data['abonnement_id'],
                        'nombre_pain' => $abonnement_data['nombre_pain'],
                    ]);
                    $productionPanetier->distribPanetiers()->save($distribPanetier);
                    $abonnement->solde_pain += $abonnement_data['nombre_pain'];
                    $abonnement->dette += ($abonnement_data['nombre_pain'] *
                        $productionPanetier->prix_pain_client);
                } else {
                    $oldNombrePain = $distribPanetier->nombre_pain;
                    $distribPanetier->nombre_pain = $abonnement_data['nombre_pain'];
                    $distribPanetier->bonus = $abonnement_data['bonus'];
                    $distribPanetier->save();
                    $abonnement->solde_pain += $abonnement_data['nombre_pain'];
                    $diff = $abonnement_data['nombre_pain'] - $oldNombrePain;
                    if ($diff > 0) {
                        $abonnement->dette += ($diff *
                            $prix_pain_client);
                    } else if ($diff < 0) {
                        $abonnement->dette -= (abs($diff) *
                            $prix_pain_client);
                    }
                }
                $abonnement->save();

            }
            // loop through boutiques and create a distribPanetier for each
            foreach ($data['boutiques'] as $boutique_data) {
                $distribPanetier = $productionPanetier->distribPanetiers()->whereBoutiqueId($boutique_data['boutique_id'])
                    ->first();
                    $boutique = Boutique::find($boutique_data['boutique_id']);
                if ($distribPanetier == null) {
                    $distribPanetier = new DistribPanetier([
                        'boutique_id' => $boutique_data['boutique_id'],
                        'nombre_pain' => $boutique_data['nombre_pain'],
                    ]);
                    $boutique->solde_pain += $boutique_data['nombre_pain'];
                    $boutique->save();
                    $productionPanetier->distribPanetiers()->save($distribPanetier);
                } else {
                    $oldNombrePain = $distribPanetier->nombre_pain;
                    $distribPanetier->nombre_pain = $boutique_data['nombre_pain'];
                    $distribPanetier->bonus = $boutique_data['bonus'];
                    $distribPanetier->save();
                    $diff = $boutique_data['nombre_pain'] - $oldNombrePain;
                    if ($diff > 0) {
                        $boutique->solde_pain += $diff;
                    } else if ($diff < 0) {
                        $boutique->solde_pain -= abs($diff);
                    }
                    $boutique->save();
                }

            }


        });


        return response()->json($data, 201);

    }


    public function destroy(DistribPanetier $distribPanetier)
    {
        $distribPanetier->delete();
        return response()->json(null, 204);
    }

    // show distrib panetier
    public function show(DistribPanetier $distribPanetier)
    {
        return response()->json($distribPanetier);
    }

    public function getEntitiesForDistrib(Request $request, ProductionPanetier $productionPanetier)
    {
        $boulangerie_id = Boulangerie::requireBoulangerieOfLoggedInUser()->id;

        $clients = Client::whereBoulangerieId($boulangerie_id)->get()->map(function (Client $client) use ($productionPanetier) {
            $data = [
                'id' => $client->id,
                'nom' => $client->identifier()

            ];
            $distribClient = $productionPanetier->distribPanetiers()->whereClientId($client->id)->first();
            if ($distribClient) {
                $data['nombre_pain'] = $distribClient->nombre_pain;
                $data['bonus'] = $distribClient->bonus;
            }
            return $data;
        });
        $livreurs = Livreur::whereBoulangerieId($boulangerie_id)->whereIsActive(true)
            ->get()->map(function (Livreur $livreur) use ($productionPanetier) {
                $data = [
                    'id' => $livreur->id,
                    'nom' => $livreur->identifier()
                ];
                $distribLivreur = $productionPanetier->distribPanetiers()->whereLivreurId($livreur->id)->first();
                if ($distribLivreur) {
                    $data['nombre_pain'] = $distribLivreur->nombre_pain;
                    $data['bonus'] = $distribLivreur->bonus;
                }
                return $data;
            });
        $abonnements = Abonnement::whereHas("client", function ($query) use ($boulangerie_id) {
            $query->where("boulangerie_id", $boulangerie_id);

        })->get()->map(function (Abonnement $abonnement) use ($productionPanetier) {
            $data = [
                'id' => $abonnement->id,
                'nom' => $abonnement->identifier()
            ];
            $distribAbonnement = $productionPanetier->distribPanetiers()->whereAbonnementId($abonnement->id)->first();
            if ($distribAbonnement) {
                $data['nombre_pain'] = $distribAbonnement->nombre_pain;
                $data['bonus'] = $distribAbonnement->bonus;
            }
            return $data;
        });
        $boutiques = Boutique::whereBoulangerieId($boulangerie_id)->orderBy('id')
            ->get(['id', 'nom'])->map(function (Boutique $boutique) use ($productionPanetier) {
                $data = [
                    'id' => $boutique->id,
                    'nom' => $boutique->nom
                ];
                $distribBoutique = $productionPanetier->distribPanetiers()->whereBoutiqueId($boutique->id)->first();
                if ($distribBoutique) {
                    $data['nombre_pain'] = $distribBoutique->nombre_pain;
                    $data['bonus'] = $distribBoutique->bonus;
                }
                return $data;
            });

        return response()->json([
            'clients' => $clients,
            'livreurs' => $livreurs,
            'abonnements' => $abonnements,
            'boutiques' => $boutiques,
        ]);
    }


}


IntrantController.php
<?php

namespace App\Http\Controllers;

use App\Models\Boulangerie;
use App\Models\Intrant;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;

class IntrantController extends Controller
{
    /**
     * Display a listing of the intrants.
     * @return JsonResponse
     */
    public function index()
    {
        $stocks = Intrant::whereBoulangerieId(Boulangerie::requireBoulangerieOfLoggedInUser()->id)->get();
        return response()->json($stocks->map(function (Intrant $intrant) {
            return [
                "id" => $intrant->id,
                "nom" => $intrant->nom,
                "stock" => $intrant->stock()->sum("quantite"),
            ];
        }));
    }

    /**
     * Store a newly created stock in storage.
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function store(Request $request)
    {
        $validatedData = $request->validate([
            'nom' => 'required|string|max:255|unique:intrants,nom',
            // Add other fields as necessary
        ]);


        $intrant = new Intrant($validatedData);
        $intrant->boulangerie()->associate(Boulangerie::requireBoulangerieOfLoggedInUser());
        $intrant->save();
        // create stock
        $intrant->stock()->create([
            "quantite" => 0,
            "nom" => "Stock de ".$intrant->nom,
            "code_bar" => now()->timestamp, // generate a unique code bar (timestamp
            "prix_achat" => 0,
            "boulangerie_id" => $intrant->boulangerie_id
        ]);
        return response()->json($intrant, 201);
    }

    /**
     * Display the specified stock.
     *
     * @param Intrant $intrant
     * @return JsonResponse
     */
    public function show(Intrant $intrant)
    {
        return response()->json($intrant);
    }

    /**
     * Update the specified stock in storage.
     *
     * @param Request $request
     * @param Intrant $intrant
     * @return JsonResponse
     */
    public function update(Request $request,Intrant $intrant)
    {
        $validatedData = $request->validate([
            'nom' => 'string|max:255|unique:intrants,nom,'.$intrant->id,
        ]);

        $intrant->update($validatedData);
        return response()->json($intrant);
    }

    /**
     * Remove the specified stock from storage.
     *
     * @param Intrant $intrant
     * @return JsonResponse
     */
    public function destroy(Intrant $intrant)
    {
        $intrant->delete();
        return response()->json(null, 204);
    }
}

LivreurController.php
<?php

namespace App\Http\Controllers;

use App\Models\Boulangerie;
use App\Models\DistribPanetier;
use App\Models\Versement;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use App\Models\Livreur;

class LivreurController extends Controller
{
    /**
     * Display a listing of the resource.
     * @return JsonResponse
     */
    public function index()
    {
        $livreurs = Livreur::whereBoulangerieId(Boulangerie::requireBoulangerieOfLoggedInUser()->id)->whereIsActive
        (true)->get()->map(function ($livreur) {
            return [
                'id' => $livreur->id,
                'prenom' => $livreur->prenom,
                'nom' => $livreur->nom,
                'telephone' => $livreur->telephone,
                'prix_pain' => $livreur->prix_pain,
                'is_active' => (bool)$livreur->is_active,
                'identifier' => $livreur->identifier(),
                'solde_reliquat' => $livreur->compteLivreur->solde_reliquat,
                'solde_pain' => $livreur->compteLivreur->solde_pain,
                'dette' => $livreur->compteLivreur->dette,

            ];
        });
        return response()->json($livreurs);
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param  Request  $request
     * @return JsonResponse
     */
    public function store(Request $request)
    {
        $validatedData = $request->validate([
            'prenom' => 'required|string|max:255',
            'nom' => 'required|string|max:255',
            'telephone' => 'required|numeric|digits:9|unique:livreurs,telephone',
            // Add other fields as necessary
        ], [
            'telephone.unique' => 'Le numéro de téléphone est déjà utilisé',
        ]);

        $livreur = new Livreur($validatedData);
        $livreur->is_active = true;
        $livreur->prix_pain = Boulangerie::requireBoulangerieOfLoggedInUser()->prix_pain_livreur;
        $livreur->boulangerie()->associate(Boulangerie::requireBoulangerieOfLoggedInUser());
        $livreur->save();
        $livreur->compteLivreur()->create();
        return response()->json($livreur, 201);
    }

    /**
     * Update the specified resource in storage.
     *
     * @param  Request  $request
     * @param  Livreur  $livreur
     * @return JsonResponse
     */
    public function update(Request $request, Livreur $livreur)
    {
        $validatedData = $request->validate([
            'prenom' => 'string|max:255',
            'nom' => 'string|max:255',
            'telephone' => 'string|digits:9|unique:livreurs,telephone,'.$livreur->id,
            // Add other fields as necessary
        ]);

        $livreur->update($validatedData);
        return response()->json($livreur);
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param  Livreur  $livreur
     * @return JsonResponse
     */
    public function destroy(Livreur $livreur)
    {
        $livreur->delete();
        return response()->json(null, 204);
    }

    /**
     * Disable the specified resource.
     *
     * @param Livreur $livreur
     * @param bool $is_active
     * @return JsonResponse
     */
    public function disable(Livreur $livreur, bool $is_active = false)
    {

        $livreur->update(['is_active' => $is_active]);
        return response()->json(['message' => 'Livreur disabled successfully']);
    }

    public function historique(Livreur $livreur)
    {
        // Get the distribPanetiers related to the current livreur
        $distribPanetiers = DistribPanetier::select([
            'nombre_pain','created_at','bonus'
        ])->with('productionPanetier')
            ->where('livreur_id', $livreur->id)
            ->get();

        // Get the versements related to the current livreur
        $versements = Versement::select(['montant_verse','date_versement','nombre_retour'])->where('livreur_id',
            $livreur->id)
            ->get();

        // Calculate the total pain taken
        $totalPainTaken = $distribPanetiers->sum('nombre_pain');

        // Calculate the total amount of versements
        $totalVersements = $versements->sum('montant_verse');

        // Calculate solde reliquat and solde pain
        $soldeReliquat = $livreur->compteLivreur->solde_reliquat;
        $soldePain = $livreur->compteLivreur->solde_pain;

        return response()->json([
            'distribPanetiers' => $distribPanetiers,
            'versements' => $versements,
            'totalPainTaken' => $totalPainTaken,
            'totalVersements' => $totalVersements,
            'soldeReliquat' => $soldeReliquat,
            "dette"=> $soldePain * Boulangerie::requireBoulangerieOfLoggedInUser()->prix_pain_livreur,
            'soldePain' => $soldePain,
        ]);
    }

    // get list of 30 distrib_panetiers of livreurs
    public function getDistribPanetiersOfLivreurs(Livreur $livreur)
    {
        $totals = [
            "valeur_pain" => $livreur->compteLivreur->dette,
            "solde_reliquat" => $livreur->compteLivreur->solde_reliquat,
            "solde_pain" => $livreur->compteLivreur->solde_pain,
        ];

        $distribPanetiers = DistribPanetier::where('livreur_id', $livreur->id)
            ->orderBy('created_at', 'desc')
            ->limit(30)
            ->get()->map(function (DistribPanetier $distribPanetier) use ($livreur) {
                return [
                    'id' => $distribPanetier->id,
                    'nombre_pain' => $distribPanetier->nombre_pain,
                    "nombre_retour" => $distribPanetier->nombre_retour,
                    "valeur_pain" => $distribPanetier->valeurPain(),
                    'prix_pain' => $livreur->prix_pain,
                    'created_at' => $distribPanetier->created_at,
                    'montant_verse'=> $distribPanetier->versement !== null ? $distribPanetier->versement->montant_verse : 0,
                    'reliquat'=> $distribPanetier->versement !== null ? $distribPanetier->versement->reliquat : 0,
                    'bonus' => $distribPanetier->bonus,
                    'verse'=> $distribPanetier->versement !== null,
                    'date_production_panetier' => $distribPanetier->productionPanetier->date_production,
                    'periode' => $distribPanetier->productionPanetier->periode,
                    "identifier"=>"Lot pains du ".$distribPanetier->productionPanetier->identifier(),
                    'production_panetier' => $distribPanetier->productionPanetier->id,
                ];
            });
        return response()->json([
            'distribPanetiers' => $distribPanetiers,
            'totals' => $totals,
        ]);

    }
}

PanetierController.php
<?php

namespace App\Http\Controllers;

use App\Http\Resources\DistribPanetierResource;
use App\Http\Resources\ProdPanetierResource;
use App\Models\Boulangerie;
use App\Models\ProductionPanetier;
use App\Rules\UniqueProductionPeriode;
use Illuminate\Http\Request;

class PanetierController extends Controller
{
    //save production panetier
    public function index()
    {
        $productions = ProductionPanetier::with('distribPanetiers')->whereBetween('date_production', [now()
                ->startOfMonth()->toDateString(), now()
            ->endOfMonth()->toDateString()])
            ->orderByDesc('date_production')
            ->get();
        return response()->json($productions);
    }

    // get production pantier du jour
    public function productionDuJour($date)
    {
        $productions = ProductionPanetier::with('distribPanetiers')->where('date_production', $date)->get();
        return response()->json($productions);
    }

    public function store(Request $request)
    {
        $data = $request->validate([
            'date_production' => ['date_format:Y-m-d','required', new UniqueProductionPeriode($request->get('date_production'), $request->get('periode'))],
            'nombre_pain' => 'required|integer',
            'nombre_plat' => 'required|integer',
            'nombre_sac' => 'required|integer',
            'ration' => 'required|integer',
            'donation' => 'required|integer',
            'casse' => 'required|integer',
            'chariots' => '|required|array',
            'periode' => 'required|in:matin,soir',
            'mange' => 'required|integer',
            'production_petrisseur_id' => 'required|integer|exists:production_petrisseurs,id',
        ]);
        $productionPanetier = new ProductionPanetier($data);
        $productionPanetier->boulangerie()->associate(Boulangerie::requireBoulangerieOfLoggedInUser());
        $productionPanetier->save();
        $productionPanetier->chariots()->createMany($request->chariots);
        return response()->json($productionPanetier->load('chariots'), 201);
    }


    public function update(Request $request, ProductionPanetier $productionPanetier)
    {
        $data = $request->validate([
            'date_production' => 'date',
            'nombre_pain' => 'integer',
            'nombre_plat' => 'integer',
            'nombre_sac' => 'integer',
            "nombre_chariot" => "integer",
            'ration' => 'integer',
            'donation' => 'integer',
            'casse' => 'integer',
            'mange' => 'integer',
            'chariots' => 'array',
        ]);
        $productionPanetier->update($data);
        return response()->json($productionPanetier);
    }

    public function destroy(ProductionPanetier $productionPanetier)
    {
        $productionPanetier->delete();
        return response()->json(null, 204);
    }

    public function show(ProductionPanetier $productionPanetier)
    {
        $productionPanetier->load('chariots');
        $productionPanetier->load('productionPetrisseur');

        $livreurs = $productionPanetier->distribPanetiers()->whereNotNull('livreur_id')->get();
        $clients = $productionPanetier->distribPanetiers()->whereNotNull('client_id')->get();
        $abonnements = $productionPanetier->distribPanetiers()->whereNotNull('abonnement_id')->get();
        $boutiques = $productionPanetier->distribPanetiers()->whereNotNull('boutique_id')->get();
        return response()->json([
            'productionPanetier' => new ProdPanetierResource($productionPanetier),
            'livreurs' => DistribPanetierResource::collection($livreurs),
            'clients' => DistribPanetierResource::collection($clients),
            'abonnements' => DistribPanetierResource::collection($abonnements),
            'boutiques' => DistribPanetierResource::collection($boutiques),

        ]);

    }



}


PetrisseurController.php
<?php

namespace App\Http\Controllers;

use App\Models\Boulangerie;
use App\Models\ChariotProdPetrisseur;
use App\Models\Company;
use App\Models\Intrant;
use App\Models\ProductionPetrisseur;
use Illuminate\Http\Request;

class PetrisseurController extends Controller
{
    // enregistre production petrisseur
    public function index()
    {
        $productions = ProductionPetrisseur::ofCurrentBoulangerie()
            ->with('prodPanetier')
            ->orderByDesc('date_production')->limit(30)
            ->get();
        return response()->json($productions);
    }
    public function productionDuJour($date)
    {
        $productions = ProductionPetrisseur::ofCurrentBoulangerie()
            ->with('chariots')
            ->where('date_production', $date)->get();

        return response()->json($productions->map(function (ProductionPetrisseur $petrisseur){
            return [
                'id' => $petrisseur->id,
                'date_production' => $petrisseur->date_production,
                'nombre_chariot' => $petrisseur->nombre_chariot,
                'nombre_sac' => $petrisseur->nombre_sac,
                'nombre_plat' => $petrisseur->nombre_plat,
                'nombre_pain' => $petrisseur->nombre_pain,
                'rendement' => $petrisseur->rendement,
                'chariots' => $petrisseur->chariots->map(function (ChariotProdPetrisseur $chariot){
                    return [
                        'id' => $chariot->id,
                        'chariot_id' => $chariot->chariot_id,
                        'nombre' => $chariot->nombre,
                        'nom_chariot' => $chariot->chariot->nom,
                        'nombre_pain' => $chariot->chariot->nombre_pain,
                    ];
                })
            ];
        }));
    }
    public function store(Request $request)
    {
        $data = $request->validate([
            // date production should be unique for a boulangerie_id
            'date_production' => 'required|date:Y-m-d|unique:production_petrisseurs,date_production,NULL,id,boulangerie_id,' . Boulangerie::requireBoulangerieOfLoggedInUser()->id,
            'nombre_chariot' => 'integer',
            'nombre_sac'  => 'required|integer', // 'nombre_sac' => 'required|integer
            'nombre_plat'  => 'required|integer',
            'nombre_pain'  => 'integer',
            "rendement" => 'integer',
            "chariots" => 'required|array',
        ], [
            'date_production.unique' => 'La production de cette date a déjà été enregistrée',
        ]);
        $production = new ProductionPetrisseur($data);

        // attach chariots
        $chariots = collect($data['chariots'])->map(function ($chariot) {
            return new ChariotProdPetrisseur($chariot);
        });

        $boulangerie = Boulangerie::requireBoulangerieOfLoggedInUser();

        $production->boulangerie()->associate($boulangerie);
        $production->save();
        $production->chariots()->saveMany($chariots);
        // réduire stock de farine
        $intrantFarine = Intrant::where('nom', 'LIKE','%farine%')
            ->whereBoulangerieId($boulangerie->id)
            ->first();
        if ($intrantFarine != null) {
            $stockFarine = $intrantFarine->stock;
            $stockFarine->diminuerStock($production->nombre_sac);
        }
        return response()->json($production, 201);

    }
    public function show(ProductionPetrisseur $petrisseur)
    {

        return response()->json($petrisseur);
    }
    public function update(Request $request, ProductionPetrisseur $petrisseur)
    {
        $data = $request->validate([
            'date_production' => 'date',
            'nombre_chariot' => 'integer',
            'nombre_sac'  => 'integer',
            'nombre_plat'  => 'integer',
            'rendement'  => 'integer',
            'nombre_pain'  => 'integer',
            'chariots' => 'array',
        ]);

        $petrisseur->update($data);
       foreach ($data['chariots'] as $chariot) {
            $chariotProd = ChariotProdPetrisseur::whereChariotId($chariot['chariot_id'])->whereProductionPetrisseurId($petrisseur->id)->first();
           $chariotProd?->update($chariot);
       }
        $petrisseur->save();
        return response()->json($petrisseur);
    }
    public function destroy(ProductionPetrisseur $petrisseur)
    {
        $petrisseur->delete();
        return response()->json(null, 204);
    }

}


ProdPatisserieController.php
<?php

namespace App\Http\Controllers;

use App\Models\Article;
use App\Models\Caisse;
use App\Models\ProdPatisserie;
use App\Models\ArticleProdPatisserie;
use App\Models\Boulangerie;
use App\Models\Recette;
use App\Models\TypeRecette;
use Carbon\Carbon;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\DB;
use Illuminate\Validation\Rule;
use Psr\Container\ContainerExceptionInterface;
use Psr\Container\NotFoundExceptionInterface;

class ProdPatisserieController extends Controller
{
    /**
     *
     * @return JsonResponse
     */
    public function index()
    {
        $prodPatisseries = ProdPatisserie::orderByDesc('date_production')
            ->get();
        return response()->json($prodPatisseries);
    }
    // get prod patisserie of a specific date
    public function getProdPatisserieByDate(Request $request, $date)
    {
        $prodPatisseries = ProdPatisserie::whereDate('date_production', '<=',$date)
            ->orderByDesc('date_production')
            ->limit(31)
            ->get()->map(function ($prodPatisserie) {
                return [
                    'id' => $prodPatisserie->id,
                    'periode' => $prodPatisserie->periode,
                    'date_production' => $prodPatisserie->date_production,
                    'verse' => (bool)$prodPatisserie->verse,
                    'montant_a_verser' => $prodPatisserie->montant_a_verser,
                    'restant_transfere' => (bool)$prodPatisserie->restant_transfere,
                    'nombre_a_verser' => $prodPatisserie->nombre_a_verser,
                    'articles' => [],
                ];
            });
        return response()->json($prodPatisseries);
    }

    /**
     *
     * @param Request $request
     * @return JsonResponse
     * @throws ContainerExceptionInterface
     * @throws NotFoundExceptionInterface
     */
    public function store(Request $request)
    {

        $validatedData = $request->validate([
            'date_production' => [
                'required',
                'date',
                Rule::unique('prod_patisseries')
                    ->where(function ($query) {
                        return $query
//                            ->where('periode', request('periode'))
                            ->where('date_production', request('date_production'));
                    }) ],
        ], [
            'date_production.unique' => 'Cette date est déjà enregistrée',
        ]);

        $prodPatisserie = new ProdPatisserie($validatedData);
        $prodPatisserie->boulangerie_id = Boulangerie::requireBoulangerieOfLoggedInUser()->id;
        $prodPatisserie->periode ='matin';

        $prodPatisserieSoir = clone $prodPatisserie;
        $prodPatisserieSoir->periode = 'soir';
        $prodPatisserie->save();
        $prodPatisserieSoir->save();



        return response()->json($prodPatisserie, 201);
    }

    /**
     *
     * @param ProdPatisserie $prodPatisserie
     * @return JsonResponse
     */
    public function show(ProdPatisserie $prodPatisserie)
    {
        $prodPatisserie->load('articleProdPatisseries.article');
        return response()->json($prodPatisserie);
    }

    /**
     * Update the specified prod patisserie in storage.
     *
     * @param Request $request
     * @param ProdPatisserie $prodPatisserie
     * @return JsonResponse
     */
    public function update(Request $request, ProdPatisserie $prodPatisserie)
    {
        $validatedData = $request->validate([
            'periode' => 'in:matin,soir',
            'date_production' => [
                'date',
                Rule::unique('prod_patisseries')
                    ->where(function ($query) {
                        return $query
                            ->where('periode', request('periode'))
                            ->where('date_production', request('date_production'));
                    })->ignore($prodPatisserie->id)],
        ]);

        $prodPatisserie->update($validatedData);

        return response()->json($prodPatisserie);
    }

    /**
     *
     * @param ProdPatisserie $prodPatisserie
     * @return JsonResponse
     */
    public function destroy(ProdPatisserie $prodPatisserie)
    {
        $prodPatisserie->forceDelete();
        return response()->json(null, 204);
    }

    /**
     *
     * @param Request $request
     * @param ProdPatisserie $prodPatisserie
     * @return JsonResponse
     */
    public function storeArticles(Request $request, ProdPatisserie $prodPatisserie)
    {
        $validatedData = $request->validate([
            'articles' => 'required|array',
            'articles.*.article_id' => 'required|exists:articles,id',
            'articles.*.restant' => 'integer',
            'articles.*.retour' => 'integer',
            'articles.*.quantite' => 'required|integer|min:1',
        ]);

        DB::transaction(function () use ($validatedData, $prodPatisserie) {
            foreach ($validatedData['articles'] as $articleData) {
                $articleProdPatisserie = new ArticleProdPatisserie($articleData);
                $articleProdPatisserie->prod_patisserie_id = $prodPatisserie->id;
                $articleProdPatisserie->save();
            }
        });

        return response()->json(['message' => 'Articles added successfully'], 201);
    }

    /**
     *
     * @param ProdPatisserie $prodPatisserie
     * @return JsonResponse
     */
    public function getArticles(ProdPatisserie $prodPatisserie)
    {
        $articles = $prodPatisserie->articles->map(function ($articleProdPatisserie) {
            return [
                'id' => $articleProdPatisserie->id,
                'article_id' => $articleProdPatisserie->article_id,
                'quantite' => $articleProdPatisserie->quantite,
                'restant' => $articleProdPatisserie->restant,
                'retour' => $articleProdPatisserie->retour,
                'article_prix' => $articleProdPatisserie->article->prix,
                'article_nom' => $articleProdPatisserie->article->nom,
            ];
        });

        return response()->json($articles);
    }
    //// ======////-======

    /**
     * Update articles for the specified ProdPatisserie.
     *
     * @param Request $request
     * @param ProdPatisserie $prodPatisserie
     * @return JsonResponse
     */
    public function updateArticles(Request $request, ProdPatisserie $prodPatisserie)
    {
        $validatedData = $request->validate([
            'articles' => 'required|array',
            'articles.*.article_id' => 'required|exists:articles,id',
            'articles.*.quantite' => 'required|integer|min:1',
            'articles.*.retour' => 'nullable|integer|min:0',
            'articles.*.restant' => 'nullable|integer|min:0',
        ]);

        DB::transaction(function () use ($validatedData, $prodPatisserie) {
            foreach ($validatedData['articles'] as $articleData) {
                $articleProdPatisserie = ArticleProdPatisserie::updateOrCreate(
                    [
                        'prod_patisserie_id' => $prodPatisserie->id,
                        'article_id' => $articleData['article_id']
                    ],
                    [
                        'quantite' => $articleData['quantite'],
                        'retour' => $articleData['retour'] ?? 0,
                        'restant' => $articleData['restant'] ?? 0,
                    ]
                );
            }
        });

        return response()->json(['message' => 'Articles updated successfully'], 200);
    }


////-======

    public function deleteArticle(ArticleProdPatisserie $articleProdPatisserie){
        $articleProdPatisserie->delete();
        return response()->json(null, 204);
    }

    public function encaisserProdPatisserie(Request $request, ProdPatisserie $prodPatisserie)
    {
        $data = $request->validate([
            'montant' => 'required|numeric',
            'articles'=>'required|array',
            // articles should have id, retour and restant attributes required
            'articles.*.id' => 'required|exists:article_prod_patisseries,id',
            'articles.*.article_id' => 'required|exists:articles,id',
            'articles.*.retour' => 'required|integer|min:0',
            'articles.*.restant' => 'required|integer|min:0',
        ]);

        // create recettes
        DB::transaction(function () use ($data, $prodPatisserie) {
            // update articles first
            foreach ($data['articles'] as $articleData) {
                $articleProdPatisserie = ArticleProdPatisserie::findOrFail($articleData['id']);
                $articleProdPatisserie->update([
                    'retour' => $articleData['retour'],
                    'restant' => $articleData['restant'],
                ]);
            }

            $recette = new Recette();
            $recette->montant = $data['montant'];
            $recette->boulangerie_id = Boulangerie::requireBoulangerieOfLoggedInUser()->id;

            $typeRecette = TypeRecette::ofCurrentBoulangerie()
                ->where('constant_name',TypeRecette::VENTE_PATISSERIE)
               ->firstOrFail();
            $recette->typeRecette()->associate($typeRecette);
            Carbon::setLocale('fr');

// Create a Carbon instance for the desired date
            $date_formatted = Carbon::parse($prodPatisserie->date_production);

// Format the date to the desired format
            $formattedDate = $date_formatted->translatedFormat('l j F Y');
            $recette->commentaire = "Encaissement de la production patisserie du " . $formattedDate." du " .
                $prodPatisserie->periode;
            $caisse = Caisse::requireCaisseOfLoggedInUser();
            $recette->caisse()->associate($caisse);
            $recette->save();
            $caisse->augmenterSolde($data['montant'],$prodPatisserie->toArray());
            $prodPatisserie->verse = true;
            $prodPatisserie->save();
        });
        return response()->json(['message' => 'Encaissement effectué avec succès'], 200);


    }

    public function transfer(ProdPatisserie $prodPatisserie, Request $request)
    {
        if ($request->isMethod('get')) {
            return $this->getTransferData($prodPatisserie);
        }

        if ($request->isMethod('post')) {
            return $this->postTransferData($prodPatisserie,$request);
        }

        return response()->json(['message' => 'Method not allowed'], 405);
    }

    /**
     * Get the nearest ProdPatisserie and articles with retour > 0.
     *
     * @param int $id
     * @return JsonResponse
     */
    protected function getTransferData(ProdPatisserie $currentProdPatisserie)
    {
        // Find the current ProdPatisserie

        // Fetch the nearest ProdPatisserie (add logic to determine the nearest one)
        $nearestProdPatisserie = ProdPatisserie::where('date_production', '>=', $currentProdPatisserie->date_production)
            ->where('id', '>', $currentProdPatisserie->id)
            ->orderBy('date_production', 'asc')
            ->first();

        // Fetch articles with retour > 0
        $articles = $currentProdPatisserie->articles()
            ->where('restant', '>', 0)
            ->get()->map(function ($articleProdPatisserie) {
                return [
                    'id' => $articleProdPatisserie->id,
                    'article_id' => $articleProdPatisserie->article_id,
                    'quantite' => $articleProdPatisserie->quantite,
                    'retour' => $articleProdPatisserie->retour,
                    'restant' => $articleProdPatisserie->restant,
                    'article_prix' => $articleProdPatisserie->article->prix,
                    'article_nom' => $articleProdPatisserie->article->nom,
                ];
            });

        return response()->json([
            'nearestProdPatisserie' => $nearestProdPatisserie,
            'articles' => $articles,
        ]);
    }

    /**
     * Handle the transfer of articles to the nearest ProdPatisserie.
     *
     * @param Request $request
     * @return JsonResponse
     */
    protected function postTransferData(ProdPatisserie $source, Request
$request)
    {
        $validated = $request->validate([
            'articles' => 'required|array',
            'articles.*.article_id' => 'required|exists:article_prod_patisseries,id',
            'destination_prod_patisserie_id' => 'required|exists:prod_patisseries,id',
        ]);
        // if already transferred it should fail validation
        if ($source->restant_transfere) {
            return response()->json(['message' => 'Articles déjà transféré'], 422);
        }

            $articlesToTransfer = $source->articles()
                ->whereIn('id', array_map(function ($article) {
                    return $article['article_id'];
                }, $validated['articles']))
                ->get();

            $destination = ProdPatisserie::findOrFail($validated['destination_prod_patisserie_id']);

            DB::transaction(function () use ($articlesToTransfer, $destination, $source) {
                foreach ($articlesToTransfer as $article) {
                    $destination->articles()->create(
                        [   'article_id' => $article->article_id,
                            'quantite' => $article->restant,
                            'retour' => 0,
                            'restant' => 0,
                        ]
                    );
                }
                $source->restant_transfere = true;
                $source->save();
            });



            // Here you could create a record that logs the transfer or perform any additional logic


        return response()->json(['message' => 'Articles transferred successfully']);
    }



}


RecetteController.php
<?php

namespace App\Http\Controllers;

use App\Http\Resources\OperationCaisseResource;
use App\Models\Boulangerie;
use App\Models\Caisse;
use App\Models\Recette;
use App\Models\TypeRecette;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;

class RecetteController extends Controller
{
    /**
     * Display a listing of the resource.
     *
     * @return JsonResponse
     */
    public function index()
    {
        $recettes = Recette::with('typeRecette')->whereCaisseId(Caisse::requireCaisseOfLoggedInUser()->id)
            ->orderByDesc('created_at')->get()
            ->map
        (function ($recette) {
            return [
                'id' => $recette->id,
                'identifier' => $recette->identifier(),
                "montant" => $recette->montant,
                'commentaire'=>$recette->commentaire,
                "created_at" => $recette->created_at,

            ];
        });
        return response()->json($recettes);
    }

    public function recettesJour($date)
    {
        $recettes = Recette::with('typeRecette')
            ->whereCaisseId(Caisse::requireCaisseOfLoggedInUser()->id)
            ->orderByDesc('created_at')->whereDate('created_at', $date)->get();
        return response()->json(OperationCaisseResource::collection($recettes));

    }

    /**
     * Store a newly created resource in storage.
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function store(Request $request)
    {
        $validated = $request->validate([
            'montant' => 'required|numeric|min:10',
            'type_recette_id' => 'required|exists:type_recettes,id',
            'commentaire' => 'nullable|string',
            "caisse_id" => "exists:caisses,id",
            // Add other fields as necessary
        ]);
        if (!isset($validated['caisse_id'])) {
            $validated['caisse_id'] = Caisse::requireCaisseOfLoggedInUser()->id;
        }
        $recette = new Recette($validated);
        $recette->boulangerie_id = Boulangerie::requireBoulangerieOfLoggedInUser()->id;
        DB::transaction(function () use ($recette) {
            $recette->save();
            $caisse = Caisse::requireCaisseOfLoggedInUser();
            $caisse->augmenterSolde($recette->montant);
        });
        $recette->refresh();
        return response()->json($recette, 201);
    }
    // update function
    public function update(Recette $recette)
    {
        $validated = request()->validate([
            'montant' => 'numeric|min:10',
            'type_recette_id' => 'exists:type_recettes,id',
            'commentaire' => 'nullable|string',
            // Add other fields as necessary
        ]);


        // update caisse solde
        DB::transaction(function () use ($validated,$recette) {
            $diff = $validated['montant'] > $recette->montant ? $validated['montant'] - $recette->montant : $recette->montant - $validated['montant'];

            $recette->update($validated);
            $caisse = Caisse::requireCaisseOfLoggedInUser();
            // calculate the difference between the old and new montant and update caisse accordingly
            if ($validated['montant'] > $recette->montant) {
                $caisse->augmenterSolde($diff);
            } else {
                $caisse->diminuerSolde($diff);
            }
            $recette->save();
            $caisse->augmenterSolde($recette->montant);
        });
        return response()->json($recette);
    }

    /**
     * Display the specified resource.
     *
     * @param Recette $recette
     * @return JsonResponse
     */
    public function show(Recette $recette)
    {
//        $recette->load('typeRecette');
        return response()->json([
            'id' => $recette->id,
            'montant' => $recette->montant,
            'commentaire' => $recette->commentaire,
            'created_at' => $recette->created_at,
            'identifier' => $recette->identifier(),

        ]);
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param Recette $recette
     * @return JsonResponse
     */
    public function destroy(Recette $recette)
    {
        DB::transaction(function () use ($recette) {
            $recette->delete();
            $caisse = Caisse::requireCaisseOfLoggedInUser();
            $caisse->diminuerSolde($recette->montant);
        });

        return response()->json(null, 204);
    }
}
   /* public function storeTypeRecette()
    {
        $validated = request()->validate([
            'nom' => 'required|string|max:255',
            // Add other fields as necessary
        ]);

        $typeRecette = TypeRecette::create($validated);
        return response()->json($typeRecette, 201);

    }
    public function updateTypeRecette(TypeRecette $typeRecette)
    {
        $validated = request()->validate([
            'nom' => 'required|string|max:255',
            // Add other fields as necessary
        ]);

        $typeRecette->update($validated);
        return response()->json($typeRecette);
    }
    public function destroyTypeRecette(TypeRecette $typeRecette)
    {
        $typeRecette->delete();
        return response()->json(null, 204);
    }
    public function indexTypeRecette()
    {
        $typeRecettes = TypeRecette::all();
        return response()->json($typeRecettes);
    }
    public function showTypeRecette(TypeRecette $typeRecette)
    {
        return response()->json($typeRecette);
    }*/


StockController.php
<?php

namespace App\Http\Controllers;

use App\Models\Boulangerie;
use App\Models\Intrant;
use App\Models\MouveIntrant;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;

class StockController extends Controller
{
    //store
    public function entreeStock(Request $request)
    {
        $validatedData = $request->validate([
            'intrants' => 'array|required',
            'intrants.*.intrant_id' => 'required|integer|exists:intrants,id',
            'intrants.*.quantite' => 'required|integer|min:1',
            'intrants.*.prix_achat' => 'required|numeric|min:1',
        ]);
        // for each intrant create intrant stock and update stock
        foreach ($validatedData['intrants'] as $intrantData) {
            $intrant = Intrant::findOrFail($intrantData['intrant_id']);
           $stock = $intrant->stock;
           if ($stock == null){
               $stock = $intrant->stock()->create([
                   "quantite" => $intrantData['quantite'],
                   "nom" => "Stock de " . $intrant->nom. ": du ".now()->format('Y-m-d H:i'),
                   "code_bar" => now()->timestamp, // generate a unique code bar (timestamp
                   "prix_achat" => $intrantData['prix_achat'],
                   "boulangerie_id" => Boulangerie::requireBoulangerieOfLoggedInUser()->id
               ]);

               $stock->mouvements()->create([
                   "quantite" => $intrantData['quantite'],
                   "stock_avant" => 0,
                   "stock_apres" => $intrantData['quantite'],
                   "type" => "in",
                   "metadata" => $stock->toArray(),
                   'boulangerie_id' => Boulangerie::requireBoulangerieOfLoggedInUser()->id
               ]);

           }else {
               $stock->update([
                   "quantite" => $stock->quantite + $intrantData['quantite'],
                   "nom" => "Stock de " . $intrant->nom . ": du " . now()->format('Y-m-d H:i'),
                   "code_bar" => now()->timestamp, // generate a unique code bar (timestamp
                   "prix_achat" => $intrantData['prix_achat'],
                   "boulangerie_id" => Boulangerie::requireBoulangerieOfLoggedInUser()->id

               ]);
                $stock->mouvements()->create([
                     "quantite" => $intrantData['quantite'],
                     "stock_avant" => $stock->quantite - $intrantData['quantite'],
                     "stock_apres" => $stock->quantite,
                     "type" => "in",
                     "metadata" => $stock->toArray(),
                        'boulangerie_id' => Boulangerie::requireBoulangerieOfLoggedInUser()->id
                ]);
           }
        }
        return response()->json(["message"=>"Stock mis à jour"], 201);
    }
    public function sortieStock(Intrant $intrant)
    {
        $validatedData = request()->validate([
            'quantite' => 'required|integer|min:1',
        ]);

        // find stock to update
        $stock = $intrant->stock;
        if ($stock->quantite < $validatedData['quantite']){
            return response()->json(["message"=>"Quantite insuffisante"], 422);
        }

        $stock->diminuerStock($validatedData['quantite']);
        $stock->save();

    }
    /**
     * Get movements for a specific intrant.
     *
     * @param Intrant $intrant
     * @return JsonResponse
     */
    public function getMovements(Intrant $intrant)
    {
        $movements = MouveIntrant::whereHas('stockIntrant', function($query) use ($intrant) {
            $query->where('intrant_id', $intrant->id);
        })->orderByDesc('created_at')->get()->map(function ($movement) {
            return [
                'id' => $movement->id,
                'type' => $movement->type,
                'quantite' => $movement->quantite,
                'stock_avant' => $movement->stock_avant,
                'stock_apres' => $movement->stock_apres,
                'created_at' => $movement->created_at->toDateTimeString(),
                'metadata' => $movement->metadata,
            ];
        });

        return response()->json($movements);
    }


}


VersementController.php
<?php

namespace App\Http\Controllers;

use App\Http\Resources\VersementResource;
use App\Models\Abonnement;
use App\Models\Boulangerie;
use App\Models\Boutique;
use App\Models\Caisse;
use App\Models\Client;
use App\Models\CompteLivreur;
use App\Models\DistribPanetier;
use App\Models\Livreur;
use App\Models\TypeRecette;
use App\Models\Versement;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;

class VersementController extends Controller
{
    public function index()
    {
        return response()->json(Livreur::where('is_active',true)->get());

    }
    public function store(Request $request)
    {
        $data = $request->validate([
            'montant' => 'required|numeric',
            'nombre_retour' => 'required|integer',
            'nombre_pain_matin' => 'integer',
            "caisse_id"=>"integer|exists:caisses,id",// 'retour' is a boolean field, so it should be
//            "date_versement"=>"date|date_format:Y-m-d",// 'retour' is a boolean field, so it should be
            'livreur_id' => 'integer|exists:livreurs,id',
            'client_id' => 'integer|exists:clients,id',
            'abonnement_id' => 'integer|exists:abonnements,id',
            'boutique_id' => 'integer|exists:boutiques,id',
            'distrib_panetier_id'=>'integer|exists:distrib_panetiers,id',
        ]);
        if (!isset($data['caisse_id'])){
            $data['caisse_id'] = Caisse::requireCaisseOfLoggedInUser()->id;
        }


        // if neither livreur_id, client_id, abonnement_id, boutique_id is set, then it's a 422 error
        if (!isset($data['livreur_id']) && !isset($data['client_id']) && !isset($data['abonnement_id']) && !isset($data['boutique_id'])){
            return response()->json(['message' => 'Vous devez choisir un livreur, un client, un abonnement ou une 
            boutique'], 422);
        }
        $versement = new Versement($data);
        $montant_verse = $data['montant'];

        DB::transaction(function () use ($data, $versement, $montant_verse) {
            $distrib_panetier = DistribPanetier::findOrFail($data['distrib_panetier_id']);
            $distrib_panetier->nombre_retour = $data['nombre_retour'];

            $versement->montant_verse = $data['montant'];
        $versement->nombre_retour = $data['nombre_retour'];
        $versement->date_versement = today()->toDateString();

        $versement->boulangerie_id = Boulangerie::requireBoulangerieOfLoggedInUser()->id;
        if ($versement->isForLivreur()){
            $livreur = Livreur::findOrFail($data['livreur_id']);
            $versement->livreur()->associate($livreur);



            // vérifier le montant versé par le livreur pour savoir s'il doit de l'argent ou on doit réduire son solde reliquat
            $compte_livreur = $livreur->compteLivreur;
            $compte_data = $compte_livreur->toArray();
            $nombre_pain_a_comptabiliser = $distrib_panetier->nombre_pain - $data['nombre_retour'];
            $montant_a_verser = $distrib_panetier->valeurPain();
            $montant_verse = $data['montant'];


            if ($montant_verse > $montant_a_verser) {
                $compte_livreur->solde_reliquat -= ($montant_verse - $montant_a_verser);
            }elseif ($montant_verse < $montant_a_verser){
                $compte_livreur->solde_reliquat += ($montant_a_verser - $montant_verse);
            }else if ($montant_verse == $montant_a_verser){
                $compte_livreur->solde_reliquat = 0;

            }
            $versement->compte_data = $compte_data;
            $versement->save();

            $compte_livreur->dette = 0;
            $compte_livreur->solde_pain = 0;
            $compte_livreur->save();

            //save distrib panetier

        }elseif ($versement->isForClient()) {
            $versement->client()->associate(Client::find($data['client_id']));
            $compte_client = $versement->client->compteClient;
            $compte_client->dette = 0;
            $compte_client->solde_pain = 0;
            $compte_client->save();
            // calculate reliquat

        }
        elseif ($versement->isForBoutique()) {
            $versement->boutique()->associate(Boutique::find($data['boutique_id']));
        }
        elseif ($versement->isForAbonnement()) {
            $versement->abonnement()->associate(Abonnement::find($data['abonnement_id']));
        }

        $versement->caisse()->associate(Caisse::find($data['caisse_id']));
        $versement->save();

        $caisse = Caisse::find($data['caisse_id']);
        $caisse->augmenterSolde($montant_verse);

            $identifier = $versement->identifier();



// Create the recette with the determined identifier
           $caisse->recettes()->create([
                'montant' => $montant_verse,

                'type_recette_id' => TypeRecette::ofCurrentBoulangerie()->where("constant_name",
                        TypeRecette::VERSEMENT_LIVREUR)
                    ->firstOrFail()->id,
                'commentaire' => 'Versement de ' . $identifier,
                'boulangerie_id' => Boulangerie::requireBoulangerieOfLoggedInUser()->id,
            ]);
            $distrib_panetier->versement()->associate($versement);
            $distrib_panetier->save();


        });



        return response()->json($versement, 201);
    }
    // update versement
    public function update(Versement $versement)
    {
        $data = request()->validate([
            'montant' => 'numeric',
            'nombre_retour' => 'integer',
            'nombre_pain_matin' => 'integer',
            "caisse_id"=>"integer|exists:caisses,id",// 'retour' is a boolean field, so it should be
            "date_versement"=>"date|date_format:Y-m-d",// 'retour' is a boolean field, so it should be
            'livreur_id' => 'nullable|integer|exists:livreurs,id',
            'client_id' => 'nullable|integer|exists:clients,id',
            'abonnement_id' => 'nullable|integer|exists:abonnements,id',
            'boutique_id' => 'nullable|integer|exists:boutiques,id',
        ]);

        DB::transaction(function () use ($data, $versement) {
            $versement->montant_verse = $data['montant'];
            $versement->nombre_retour = $data['nombre_retour'];
            $versement->date_versement = $data['date_versement'];
            $versement->boulangerie_id = Boulangerie::requireBoulangerieOfLoggedInUser()->id;

            $livreur = Livreur::findOrFail($data['livreur_id']);
            $versement->livreur()->associate($livreur);
            $versement->caisse()->associate(Caisse::find($data['caisse_id']));

            $versement->save();

            // vérifier le montant versé par le livreur pour savoir s'il doit de l'argent ou on doit réduire son solde reliquat
            $compte_livreur = $livreur->compteLivreur;
            $nombre_pain_a_comptabiliser = $compte_livreur->solde_pain - $data['nombre_retour'];
            $montant_a_verser = $nombre_pain_a_comptabiliser * $livreur->prix_pain;
            $montant_verse = $data['montant'];

            if ($montant_verse > $montant_a_verser) {
                $compte_livreur->solde_reliquat -= ($montant_verse - $montant_a_verser);
            } elseif ($montant_verse < $montant_a_verser) {
                $compte_livreur->solde_reliquat += ($montant_a_verser - $montant_verse);
            }
            $compte_data = $compte_livreur->toArray();
            $versement->compte_data = $compte_data;
        });

    }
    public function destroy(Versement $versement)
    {

        DB::transaction(function () use ($versement) {
            $livreur = $versement->livreur;
            $compte_livreur = $livreur->compteLivreur;
            $compte_livreurWhenVersementWasMade = new CompteLivreur($versement->compte_data);

            $compte_livreur->augmenterDette($compte_livreurWhenVersementWasMade->dette);
            $compte_livreur->augmenterSoldePain($compte_livreurWhenVersementWasMade->solde_pain);
            // check if we should increase or decrease the solde reliquat
            $nombre_pain_a_comptabiliser = $compte_livreur->solde_pain - $versement->nombre_retour;
            $montant_a_verser = $nombre_pain_a_comptabiliser * $livreur->prix_pain;
            $montant_verse = $versement->montant_verse;
            $compte_livreur->save();
            /** @var  $caisse Caisse */
            $caisse = Caisse::find($versement->caisse_id);
            $solde_avant = $caisse->solde;
            $caisse->diminuerSolde($montant_verse);
            $caisse->transactions()->create([
                'montant' => $montant_verse,
                'type' => 'cashout',
                "solde_apres" => $caisse->solde + $montant_verse,
                "solde_avant" => $solde_avant,

                'commentaire' => 'Suppression du versement'
            ]);
            $caisse->save();
            $versement->delete();

        });
        return response()->json(null, 204);

    }

    public function versementsLivreurs()
    {
        Versement::factory()->count(10)->create();
        $boulangerie = Boulangerie::requireBoulangerieOfLoggedInUser();
        $livreurs = $boulangerie->livreurs()->with('versements')->where('is_active',true)->get();

        return response()->json($livreurs);

    }
    public function versementsDate($date){

        $boulangerie = Boulangerie::requireBoulangerieOfLoggedInUser();
        // group versements by livreur, client, boutique, abonnement
        $livreurs = $boulangerie->versements()->whereDate('created_at',$date)->where('livreur_id','!=',null)
            ->orderByDesc('created_at')
            ->get();
        $clients = $boulangerie->versements()->whereDate('created_at',$date)->where('client_id','!=',null)
            ->orderByDesc('created_at')
            ->get();
        $abonnements = $boulangerie->versements()->whereDate('created_at',$date)->where('abonnement_id','!=',null)
            ->orderByDesc('created_at')
            ->get();
        $boutiques = $boulangerie->versements()->whereDate('created_at',$date)->where('boutique_id','!=',null)
            ->orderByDesc('created_at')
            ->get();

        return response()->json([
            'livreurs' => VersementResource::collection($livreurs),
            'clients' => VersementResource::collection($clients),
            'abonnements' => VersementResource::collection($abonnements),
            'boutiques' => VersementResource::collection($boutiques),
        ]);
    }
    public function destinations()
    {
        $boulangerie = Boulangerie::requireBoulangerieOfLoggedInUser();
        $livreurs = $boulangerie->livreurs()->where('is_active',true)->get();
        $clients = $boulangerie->clients;
        $abonnements = $boulangerie->abonnements;
        $boutiques = $boulangerie->boutiques;
        return response()->json([
            'livreurs' => $livreurs->map(function (Livreur $livreur){
                return [
                    'id' => $livreur->id,
                    'nom' => $livreur->identifier(),
                    'solde_pain' => $livreur->compteLivreur->solde_pain,
                    'solde_reliquat' => $livreur->compteLivreur->solde_reliquat,
                    'dette' => $livreur->compteLivreur->dette,
                ];
            }),
            'clients' => $clients->map(function (Client $client){
                return [
                    'id' => $client->id,
                    'nom' => $client->nom,
                    'solde_pain' => $client->compteClient->solde_pain,
                    'dette' => $client->compteClient->dette,
                ];
            }),
            'abonnements' => $abonnements->map(function (Abonnement $abonnement){
                return [
                    'id' => $abonnement->id,
                    'nom' => $abonnement->identifier(),
                    'solde_pain' => $abonnement->solde_pain,
                    'dette' => $abonnement->dette,
                ];
            }),
            'boutiques' => $boutiques->map(function (Boutique $boutique){
                return [
                    'id' => $boutique->id,
                    'nom' => $boutique->identifier(),
                    'solde_pain' => $boutique->solde_pain,
                ];
            }),
        ]);

    }
}



Here are my Factories:
AbonnementFactory.php
<?php

namespace Database\Factories;

use App\Models\Abonnement;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Carbon;

class AbonnementFactory extends Factory
{
    protected $model = Abonnement::class;

    public function definition(): array
    {
        return [
            'date_debut' => Carbon::now()->toDateString(),
            'date_fin' => Carbon::now()->addMonth()->toDateString()
        ];
    }
}


ArticleFactory.php
<?php

namespace Database\Factories;

use App\Models\Article;
use App\Models\Boulangerie;
use Illuminate\Database\Eloquent\Factories\Factory;

class ArticleFactory extends Factory
{
    protected $model = Article::class;

    public function definition(): array
    {
        return [
            'nom' => $this->faker->unique()->word,
            'prix' => $this->faker->numberBetween(100, 10000),
            'boulangerie_id' => Boulangerie::factory()::mockActiveBoulangerie()->id,
        ];
    }
}


ArticleProdPatisserieFactory.php
<?php

namespace Database\Factories;

use App\Models\ArticleProdPatisserie;
use App\Models\Article;
use App\Models\ProdPatisserie;
use Illuminate\Database\Eloquent\Factories\Factory;

class ArticleProdPatisserieFactory extends Factory
{
    protected $model = ArticleProdPatisserie::class;

    public function definition(): array
    {
        return [
            'article_id' => Article::factory(),
            'prod_patisserie_id' => ProdPatisserie::factory(),
            'restant' => $this->faker->numberBetween(1, 10),
            'retour' => $this->faker->numberBetween(1, 10),
            'quantite' => $this->faker->numberBetween(1, 100),
        ];
    }
}


BoulangerieFactory.php
<?php

namespace Database\Factories;

use App\Models\Boulangerie;
use App\Models\Company;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Database\Eloquent\Model;

/**
 * @extends Factory<Boulangerie>
 */
class BoulangerieFactory extends Factory
{

    static ?Boulangerie $boulangerieSingleton = null;

    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [
            "nom" => $this->faker->company(),
            "created_at" => now(),
            "company_id" => Company::factory()->create()->id,
            //
        ];
    }


    public static function mockActiveBoulangerie(): Boulangerie
    {
        if (self::$boulangerieSingleton === null) {
            self::$boulangerieSingleton = Boulangerie::factory()->create();
        }
        return self::$boulangerieSingleton;
    }


}


BoutiqueFactory.php
<?php

namespace Database\Factories;

use App\Models\Boutique;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Carbon;

class BoutiqueFactory extends Factory
{
    protected $model = Boutique::class;

    public function definition(): array
    {
        return [
            'nom' => $this->faker->company(),
            'solde_pain' => 0,
            'adresse' => $this->faker->address(),

        ];
    }
}


CaisseFactory.php
<?php

namespace Database\Factories;

use App\Models\Boulangerie;
use App\Models\Caisse;
use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends Factory<Caisse>
 */
class CaisseFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        $definition = [
            "nom" => "Caisse Principale",

            //
        ];
        // if env is testing, we can add the following fields
        if (app()->environment('testing')) {
            $definition["boulangerie_id"] =  Boulangerie::factory()::mockActiveBoulangerie()->id;
        }
        return $definition;
    }
}


CaisseTransactionFactory.php
<?php

namespace Database\Factories;

use App\Models\CaisseTransaction;
use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends Factory<CaisseTransaction>
 */
class CaisseTransactionFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [
            'montant' => $this->faker->randomNumber(9),
            'commentaire' => $this->faker->sentence(),
            'solde_avant' => $this->faker->randomNumber(9),
            'solde_apres' => $this->faker->randomNumber(9),
            'type' => $this->faker->randomElement(['cashin', 'cashout']),
            'metadata' => $this->faker->hslColorAsArray(),
            'created_at' => $this->faker->dateTimeBetween(startDate: '-30 days',     endDate: 'now'),

        ];
    }
}


ChariotFactory.php
<?php

namespace Database\Factories;

use App\Models\Boulangerie;
use App\Models\Caisse;
use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends Factory<Caisse>
 */
class ChariotFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        $definition = [
            "nom" => "Chariot ".$this->faker->numberBetween(100, 500)." pains ",
            "nombre_pain" => $this->faker->numberBetween(100, 500),

            //
        ];
        if (app()->environment('testing')) {
            $definition["boulangerie_id"] =  Boulangerie::factory()::mockActiveBoulangerie()->id;
        }
        return $definition;
    }
}


ChariotProdPanetierFactory.php
<?php

namespace Database\Factories;

use App\Models\Chariot;
use App\Models\ChariotProdPanetier;
use App\Models\ProductionPanetier;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Carbon;

class ChariotProdPanetierFactory extends Factory
{
    protected $model = ChariotProdPanetier::class;

    public function definition(): array
    {
        return [
            'production_panetier_id' => ProductionPanetier::factory(),
            'chariot_id' => Chariot::factory(),
            'nombre' => $this->faker->numberBetween(100, 1000),
        ];
    }
}


ChariotProdPetrisseurFactory.php
<?php

namespace Database\Factories;

use App\Models\ChariotProdPetrisseur;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Carbon;

class ChariotProdPetrisseurFactory extends Factory
{
    protected $model = ChariotProdPetrisseur::class;

    public function definition(): array
    {
        return [
        ];
    }
}


ClientFactory.php
<?php

namespace Database\Factories;

use App\Models\Boulangerie;
use App\Models\Client;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Carbon;

class ClientFactory extends Factory
{
    protected $model = Client::class;

    public function definition(): array
    {
        return [
            'prenom' => $this->faker->firstName(),
            'nom' => $this->faker->lastName(),
            'telephone' => $this->faker->phoneNumber(),
            'created_at' => Carbon::now(),
            'updated_at' => Carbon::now(),
        ];
    }
}


CompanyFactory.php
<?php

namespace Database\Factories;

use App\Models\Company;
use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends Factory<Company>
 */
class CompanyFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [
            "nom" => $this->faker->company(),
            "created_at" => now(),
            //
        ];
    }
}


CompteClientFactory.php
<?php

namespace Database\Factories;

use App\Models\Client;
use App\Models\CompteClient;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Carbon;

class CompteClientFactory extends Factory
{
    protected $model = CompteClient::class;

    public function definition(): array
    {
        return [
            'solde_pain' => 0,
            'dette' => 0,
            'solde_reliquat' => 0,
        ];
    }
}


CompteLivreurFactory.php
<?php

namespace Database\Factories;

use App\Models\CompteLivreur;
use App\Models\Livreur;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Carbon;

class CompteLivreurFactory extends Factory
{
    protected $model = CompteLivreur::class;

    public function definition(): array
    {
        return [
            'solde_pain' => 0,
            'dette' =>0,
            'solde_reliquat' => 0,
        ];
    }
}


DepenseFactory.php
<?php

namespace Database\Factories;

use App\Models\Caisse;
use App\Models\Depense;
use App\Models\TypeDepense;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Carbon;

class DepenseFactory extends Factory
{
    protected $model = Depense::class;

    public function definition(): array
    {
        $definition= [
            'type_depense_id' => TypeDepense::factory(),
            'montant' => $this->faker->numberBetween(1000, 1000000),
            'commentaire' => $this->faker->sentence(10),
        ];
        if (app()->environment('testing')) {
            $definition["caisse_id"] =  Caisse::requireCaisseOfLoggedInUser();
        }
        return $definition;
    }
}


DistribPanetierFactory.php
<?php

namespace Database\Factories;

use App\Models\DistribPanetier;
use App\Models\Livreur;
use App\Models\ProductionPanetier;
use Illuminate\Database\Eloquent\Factories\Factory;
use Termwind\Components\Li;

class DistribPanetierFactory extends Factory
{
    protected $model = DistribPanetier::class;

    public function definition(): array
    {
        $definition = [
            "livreur_id" => Livreur::factory(),
            "nombre_pain" => $this->faker->numberBetween(100, 1000)
        ];
         if (app()->environment('testing')) {
             $definition["production_panetier_id"] =  ProductionPanetier::factory();
         }
         return $definition;
    }

}


IntrantFactory.php
<?php

namespace Database\Factories;

use App\Models\Boulangerie;
use App\Models\Intrant;
use App\Models\StockIntrant;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Carbon;

class IntrantFactory extends Factory
{
    protected $model = Intrant::class;

    public function definition(): array
    {
        return [
            'nom' => $this->faker->unique()->word(),
        ];
    }
    public function configure(): IntrantFactory
    {
        return $this->afterCreating(function (Intrant $intrant) {

        });
    }
}


LivreurFactory.php
<?php

namespace Database\Factories;

use App\Models\Boulangerie;
use App\Models\Livreur;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Carbon;

class LivreurFactory extends Factory
{
    protected $model = Livreur::class;

    public function definition(): array
    {
        $definition = [
            'prenom' => $this->faker->firstName(),
            'nom' => $this->faker->lastName(),
            'telephone' => '77' . $this->faker->unique()->randomNumber(7),
        ];
        if (app()->environment('testing')) {
            $definition["boulangerie_id"] =  Boulangerie::factory()::mockActiveBoulangerie()->id;
        }
        return $definition;
    }
    // add compte livreur
    public function configure(): LivreurFactory
    {
        return $this->afterCreating(function (Livreur $livreur) {
            $livreur->compteLivreur()->create([
                'solde_pain' => 0,
                'dette' => 0,
                'solde_reliquat' => 0,
            ]);
        });
    }
}


MouveIntrantFactory.php
<?php

namespace Database\Factories;

use App\Models\Boulangerie;
use App\Models\MouveIntrant;
use App\Models\StockIntrant;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Carbon;

class MouveIntrantFactory extends Factory
{
    protected $model = MouveIntrant::class;

    public function definition(): array
    {
        $definition = [
            'quantite' => $this->faker->randomNumber(),
            'stock_avant' => $this->faker->randomNumber(),
            'stock_apres' => $this->faker->randomNumber(),
            'type' => $this->faker->randomElement(['in', 'out']),
            'metadata' => $this->faker->shuffleArray(['key' => 'value']),

            'created_at' => Carbon::now(),
            'updated_at' => Carbon::now(),
        ];
        if (app()->environment() === 'testing') {
            $definition['boutique_id'] = Boulangerie::factory();
            $definition['stock_intrant_id'] = StockIntrant::factory();
        }
        return  $definition;
    }
}


ProdPatisserieFactory.php
<?php

namespace Database\Factories;

use App\Models\ProdPatisserie;
use App\Models\Boulangerie;
use Illuminate\Database\Eloquent\Factories\Factory;

class ProdPatisserieFactory extends Factory
{
    protected $model = ProdPatisserie::class;

    public function definition(): array
    {
        return [
            'date_production' => today()->toDateString(),
            'periode' => $this->faker->randomElement(['matin', 'soir']),
//            'boulangerie_id' => Boulangerie::factory()::mockActiveBoulangerie(),
        ];
    }
}


ProductionPanetierFactory.php
<?php

namespace Database\Factories;

use App\Models\Boulangerie;
use App\Models\ProductionPanetier;
use Illuminate\Database\Eloquent\Factories\Factory;

class ProductionPanetierFactory extends Factory
{
    protected $model = ProductionPanetier::class;

    public function definition(): array
    {
        $definition= [
            'date_production' => today()->toDateString(),
            'nombre_pain' => $this->faker->numberBetween(1000,10000),
            'nombre_plat' => $this->faker->numberBetween(100,1000),
            'nombre_sac' => $this->faker->numberBetween(1,100),
            'ration' => $this->faker->numberBetween(10,100),
            'donation' => $this->faker->numberBetween(10,100),
            'casse' => $this->faker->numberBetween(10,100),
            'mange' => $this->faker->numberBetween(10,100),
            'periode' => $this->faker->randomElement(['matin', 'soir']),

        ];
        if (app()->environment('testing')) {
            $definition["boulangerie_id"] =  Boulangerie::factory()::mockActiveBoulangerie()->id;
        }
        return $definition;
    }
}


ProductionPetrisseurFactory.php
<?php

namespace Database\Factories;

use App\Models\Boulangerie;
use App\Models\Company;
use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends Factory<Company>
 */
class ProductionPetrisseurFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        $definition = [
            "date_production" => $this->faker->date(),
            "nombre_chariot" => $this->faker->numberBetween(1, 100),
            "nombre_pain" => $this->faker->numberBetween(3000, 9000),
            "nombre_plat" => $this->faker->numberBetween(1, 100),
            "nombre_sac" => $this->faker->numberBetween(1, 30),

            //
        ];
        if (app()->environment('testing')) {
            $definition["boulangerie_id"] =  Boulangerie::factory()::mockActiveBoulangerie()->id;
        }
        return $definition;
    }
}


RecetteFactory.php
<?php

namespace Database\Factories;

use App\Models\Boulangerie;
use App\Models\Caisse;
use App\Models\Recette;
use App\Models\TypeRecette;
use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends Factory<Recette>
 */
class RecetteFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [

            'montant' => $this->faker->numberBetween(100, 1000000),
            "type_recette_id" => TypeRecette::factory(),
            "boulangerie_id" => Boulangerie::factory(),
            'commentaire' => $this->faker->sentence(15),

        ];
    }
}


TypeDepenseFactory.php
<?php

namespace Database\Factories;

use App\Models\Boulangerie;
use App\Models\TypeDepense;
use Illuminate\Database\Eloquent\Factories\Factory;

class TypeDepenseFactory extends Factory
{
    protected $model = TypeDepense::class;

    public function definition(): array
    {
        $definition = [
            'nom' => $this->faker->name(),
        ];
        if (app()->environment('testing')) {
            $definition["boulangerie_id"] =  Boulangerie::factory()::mockActiveBoulangerie()->id;
        }
        return $definition;
    }
}


TypeRecetteFactory.php
<?php

namespace Database\Factories;

use App\Models\Boulangerie;
use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\TypeRecette>
 */
class TypeRecetteFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        $definition = [
            'nom' => $this->faker->word,


        ];
        if (app()->environment('testing')) {
            $definition["boulangerie_id"] =  Boulangerie::factory()::mockActiveBoulangerie()->id;
        }
        return $definition;
    }
}


UserFactory.php
<?php

namespace Database\Factories;

use App\Models\User;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Carbon;
use Illuminate\Support\Str;

class UserFactory extends Factory
{
    protected $model = User::class;

    public function definition(): array
    {
        return [
            'name' => $this->faker->name(),
            'email' => $this->faker->unique()->safeEmail(),
            'email_verified_at' => Carbon::now(),
            'password' => bcrypt($this->faker->password()),
            'remember_token' => Str::random(10),
            'created_at' => Carbon::now(),
            'updated_at' => Carbon::now(),
        ];
    }
}


VersementFactory.php
<?php

namespace Database\Factories;

use App\Models\Boulangerie;
use App\Models\Caisse;
use App\Models\CompteLivreur;
use App\Models\Livreur;
use App\Models\Versement;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Carbon;

class VersementFactory extends Factory
{
    protected $model = Versement::class;

    public function definition(): array
    {
        $definition = [
            'nombre_pain_matin' => $this->faker->randomNumber(),
            'nombre_pain_soir' => $this->faker->randomNumber(),
            'nombre_retour' => $this->faker->randomNumber(),
            'montant_verse' => $this->faker->numberBetween(10000, 900000),
            'date_versement' => Carbon::now(),
            'caisse_id' => Caisse::factory(),
            'compte_data'=>(new CompteLivreur([
                'solde_pain'=> $this->faker->randomNumber(),
                'solde_reliquat'=> $this->faker->randomNumber(),
                "dette" => $this->faker->randomNumber(),
                "prix_pain" => $this->faker->randomNumber(),
            ]))->toArray(),
        ];
        if (app()->environment('testing')) {
            $definition["boulangerie_id"] =  Boulangerie::factory()::mockActiveBoulangerie()->id;
        }
        return $definition;
    }
}



